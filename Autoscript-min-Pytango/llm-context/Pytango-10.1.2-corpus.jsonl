{"doc_id": "f6ce5fdaa96951d1a3be08867f54848d3d4bcfee", "path": "pytango-docsv10.1.12/api/client_api/device_proxy.md", "section": "DeviceProxy", "level": 1, "chunk_id": "0.0", "text": "# DeviceProxy\n\n```{eval-rst}\n.. autoclass:: tango.DeviceProxy\n :show-inheritance:\n :members:\n :inherited-members:\n```\n\n```{eval-rst}\n.. autofunction:: tango.get_device_proxy\n```", "text_sha1": "49ba0f27371354aea49a8781089ec9a12ebf7a44"}
{"doc_id": "2509ceec8f8dc8bf61c2d1cfa42a454edebe9038", "path": "pytango-docsv10.1.12/api/client_api/green.md", "section": "Green API", "level": 1, "chunk_id": "0.0", "text": "# Green API\n\nSummary:\n: - {func}`tango.get_green_mode`\n - {func}`tango.set_green_mode`\n - {func}`tango.asyncio.DeviceProxy`\n - {func}`tango.futures.DeviceProxy`\n - {func}`tango.gevent.DeviceProxy`\n\n```{eval-rst}\n.. autofunction:: tango.get_green_mode\n```\n\n```{eval-rst}\n.. autofunction:: tango.set_green_mode\n```\n\n```{eval-rst}\n.. autofunction:: tango.asyncio.DeviceProxy\n```\n\n```{eval-rst}\n.. autofunction:: tango.futures.DeviceProxy\n```\n\n```{eval-rst}\n.. autofunction:: tango.gevent.DeviceProxy\n```", "text_sha1": "53cb9299ea0228a75dac7d6c5b44880edc52f2ad"}
{"doc_id": "dd53caeefec9682bbe60904b0935b23b8872a7d2", "path": "pytango-docsv10.1.12/api/client_api/group.md", "section": "Group", "level": 1, "chunk_id": "0.0", "text": "# Group\n\n```{eval-rst}\n.. currentmodule:: tango\n\n```\n\n% GroupElement is the base class of Group, but is not the base of\n% anything else. So, I don't include it in the documentation but just\n% add its functions into Group by using :inherited-members:", "text_sha1": "321b790b62c5b5045fae6c123b3876b0c13558e0"}
{"doc_id": "dd53caeefec9682bbe60904b0935b23b8872a7d2", "path": "pytango-docsv10.1.12/api/client_api/group.md", "section": "GroupReply classes", "level": 2, "chunk_id": "2.0", "text": "## GroupReply classes\n\nGroup member functions do not return the same as their DeviceProxy counterparts,\nbut objects that contain them. This is:\n\n> - *write attribute* family returns tango.GroupReplyList\n> - *read attribute* family returns tango.GroupAttrReplyList\n> - *command inout* family returns tango.GroupCmdReplyList\n\nThe Group\\*ReplyList objects are just list-like objects containing\n{class}`~tango.GroupReply`, {class}`~tango.GroupAttrReply` and\n{class}`~GroupCmdReply` elements that will be described now.\n\nNote also that GroupReply is the base of GroupCmdReply and GroupAttrReply.\n\n```{eval-rst}\n.. autoclass:: tango.GroupReply\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.GroupAttrReply\n :show-inheritance:\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: GroupCmdReply\n :show-inheritance:\n :members:\n```", "text_sha1": "0b9e33c86ed551c900f1a3e995e7e838d82664b8"}
{"doc_id": "e04abb4f21a486a05bf090069dfda7999a8a9941", "path": "pytango-docsv10.1.12/api/client_api/miscellaneous.md", "section": "Attribute", "level": 2, "chunk_id": "2.0", "text": "## Attribute\n\n```{eval-rst}\n.. autoclass:: AttributeAlarmInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: AttributeDimension\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: AttributeInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: AttributeInfoEx\n :members:\n```\n\nsee also {class}`AttributeInfo`\n\n```{eval-rst}\n.. autoclass:: DeviceAttributeConfig\n :members:\n```", "text_sha1": "8d0fc06da77813ba3a738f40bb86df3cb9f88a57"}
{"doc_id": "e04abb4f21a486a05bf090069dfda7999a8a9941", "path": "pytango-docsv10.1.12/api/client_api/miscellaneous.md", "section": "Other", "level": 2, "chunk_id": "4.0", "text": "## Other\n\n```{eval-rst}\n.. autoclass:: DeviceInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: LockerInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: PollDevice\n :members:\n\n```", "text_sha1": "3ac8568fe4effc902247c06e8d9de6344bbbcf48"}
{"doc_id": "e04abb4f21a486a05bf090069dfda7999a8a9941", "path": "pytango-docsv10.1.12/api/client_api/miscellaneous.md", "section": "Command: DeviceData", "level": 2, "chunk_id": "7.0", "text": "## Command: DeviceData\n\nDevice data is the type used internally by Tango to deal with command parameters\nand return values. You don't usually need to deal with it, as command_inout\nwill automatically convert the parameters from any other type and the result\nvalue to another type.\n\nYou can still use them, using command_inout_raw to get the result in a DeviceData.\n\nYou also may deal with it when reading command history.\n\n```{eval-rst}\n.. autoclass:: DeviceData\n :members:\n\n```", "text_sha1": "3f1665c247b0f673edc2dcee57c40d68718a58ab"}
{"doc_id": "e04abb4f21a486a05bf090069dfda7999a8a9941", "path": "pytango-docsv10.1.12/api/client_api/miscellaneous.md", "section": "Callback related classes", "level": 1, "chunk_id": "8.0", "text": "# Callback related classes\n\nIf you subscribe a callback in a DeviceProxy, it will be run with a parameter.\nThis parameter depends will be of one of the following classes depending on\nthe callback type.\n\n```{eval-rst}\n.. autoclass:: AttrReadEvent\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: AttrWrittenEvent\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: CmdDoneEvent\n :members:\n\n```", "text_sha1": "8a553d07fe0f1108e9aa9405d6410930031f5b63"}
{"doc_id": "e04abb4f21a486a05bf090069dfda7999a8a9941", "path": "pytango-docsv10.1.12/api/client_api/miscellaneous.md", "section": "Event configuration information", "level": 2, "chunk_id": "10.0", "text": "## Event configuration information\n\n```{eval-rst}\n.. autoclass:: AttributeEventInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: ArchiveEventInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: ChangeEventInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: PeriodicEventInfo\n :members:\n```", "text_sha1": "2465e74b4531fad7921baf59231759fb018fa66c"}
{"doc_id": "e04abb4f21a486a05bf090069dfda7999a8a9941", "path": "pytango-docsv10.1.12/api/client_api/miscellaneous.md", "section": "Event arrived structures", "level": 2, "chunk_id": "12.0", "text": "## Event arrived structures\n\n```{eval-rst}\n.. autoclass:: EventData\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: AttrConfEventData\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: DataReadyEventData\n :members:\n\n```\n\n```{eval-rst}\n.. autoclass:: DevIntrChangeEventData\n :members:\n\n```\n\n```{eval-rst}\n.. autoclass:: EventReason\n :members:\n```", "text_sha1": "d37d6db970fd9703844bd1612dff0ee19a0ac612"}
{"doc_id": "e04abb4f21a486a05bf090069dfda7999a8a9941", "path": "pytango-docsv10.1.12/api/client_api/miscellaneous.md", "section": "History classes", "level": 1, "chunk_id": "13.0", "text": "# History classes\n\n```{eval-rst}\n.. autoclass:: DeviceAttributeHistory\n :show-inheritance:\n :members:\n```\n\nSee {class}`DeviceAttribute`.\n\n```{eval-rst}\n.. autoclass:: DeviceDataHistory\n :show-inheritance:\n :members:\n```\n\nSee {class}`DeviceData`.", "text_sha1": "35addf2223e39f981f665fd58d41da1e1aea9422"}
{"doc_id": "6536977f06cc026fc2dfec0a9b3c96c5661a8926", "path": "pytango-docsv10.1.12/api/data_types.md", "section": "Data types", "level": 1, "chunk_id": "0.0", "text": "# Data types\n\nThis chapter describes the mapping of data types between Python and Tango.\n\nTango has more data types than Python which is more dynamic. The input and\noutput values of the commands are translated according to the array below.\nNote that the numpy type is used for the input arguments.\nAlso, it is recommended to use numpy arrays of the appropiate type for output\narguments as well, as they tend to be much more efficient.\n\n**For scalar types (SCALAR)**\n\n```{eval-rst}\n+-------------------------+---------------------------------------------------------------------------+\n| Tango data type | Python data type |\n+=========================+===========================================================================+\n| DEV_VOID | No data |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_BOOLEAN | :py:obj:`bool` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_SHORT | :py:obj:`int` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_LONG | :py:obj:`int` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_LONG64 | :py:obj:`int` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_FLOAT | :py:obj:`float` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_DOUBLE | :py:obj:`float` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_USHORT | :py:obj:`int` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_ULONG | :py:obj:`int` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_ULONG64 | :py:obj:`int` |\n+-------------------------+---------------------------------------------------------------------------+\n| DEV_STRING | :py:obj:`str` (decoded with *latin-1*, aka *ISO-8859-1*) |\n+-------------------------+---------------------------------------------------------------------------+\n| | sequence of two elements: |\n| DEV_ENCODED | |\n| | 0. :py:obj:`str` (decoded with *latin-1*, aka *ISO-8859-1*) |\n| (*New in PyTango 8.0*) | 1. :py:obj:`bytes` (for any value of *extract_as*, except String. |\n| | In this case it is :py:obj:`str` (decoded with default python |\n| | encoding *utf-8*)) |\n+-------------------------+---------------------------------------------------------------------------+\n| | * :py:obj:`int` (for value) |\n| | * :py:class:`list` <:py:obj:`str`> (for enum_labels) |\n| DEV_ENUM | |\n| | Note: |\n| (*New in PyTango 9.0*) | Direct attribute access via DeviceProxy will return |\n| | :py:obj:`enum.IntEnum`. |\n+-------------------------+---------------------------------------------------------------------------+\n```\n\n**For array types (SPECTRUM/IMAGE)**\n\n```{eval-rst}\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| Tango data type | ExtractAs | Python data type |\n+=========================+=================+=========================================================================+\n| DEVVAR_CHARARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.uint8`) |\n| +-----------------+--------------------------------------------------", "text_sha1": "1108888b0842d6def2b0b14ebbf85abaa22564cb"}
{"doc_id": "6536977f06cc026fc2dfec0a9b3c96c5661a8926", "path": "pytango-docsv10.1.12/api/data_types.md", "section": "Data types", "level": 1, "chunk_id": "0.1", "text": "-----------------------+\n| | Bytes | :py:obj:`bytes` |\n| +-----------------+-------------------------------------------------------------------------+\n| | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`int`> |\n| +-----------------+-------------------------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`int`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_SHORTARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.uint16`) |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_SHORT + SPECTRUM) | Bytes | :py:obj:`bytes` |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_SHORT + IMAGE) | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`int`> |\n| +-----------------+-------------------------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`int`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_LONGARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.uint32`) |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_LONG + SPECTRUM) | Bytes | :py:obj:`bytes` |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_LONG + IMAGE) | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`int`> |\n| +-----------------+-------------------------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`int`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_LONG64ARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.uint64`) |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_LONG64 + SPECTRUM) | Bytes | :py:obj:`bytes` |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_LONG64 + IMAGE) | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`int`> |\n| +-----------------+---------------", "text_sha1": "988df509d88609537788e77d7fe76c35569fbf79"}
{"doc_id": "6536977f06cc026fc2dfec0a9b3c96c5661a8926", "path": "pytango-docsv10.1.12/api/data_types.md", "section": "Data types", "level": 1, "chunk_id": "0.2", "text": "----------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`int`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_FLOATARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.float32`) |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_FLOAT + SPECTRUM) | Bytes | :py:obj:`bytes` |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_FLOAT + IMAGE) | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`float`> |\n| +-----------------+-------------------------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`float`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_DOUBLEARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.float64`) |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_DOUBLE + SPECTRUM) | Bytes | :py:obj:`bytes` |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_DOUBLE + IMAGE) | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`float`> |\n| +-----------------+-------------------------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`float`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_USHORTARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.uint16`) |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_USHORT + SPECTRUM) | Bytes | :py:obj:`bytes` |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_USHORT + IMAGE) | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`int`> |\n| +-----------------+-------------------------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`int`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_ULONGARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.uint32`) |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_ULONG + SPECTRUM) | Bytes | :py:obj:`bytes` |\n| +-----------------+-----------------------------------------------", "text_sha1": "707ac9bab43159a427ca71dd226cc46c95ed2f07"}
{"doc_id": "6536977f06cc026fc2dfec0a9b3c96c5661a8926", "path": "pytango-docsv10.1.12/api/data_types.md", "section": "Data types", "level": 1, "chunk_id": "0.3", "text": "--------------------------+\n| (DEV_ULONG + IMAGE) | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`int`> |\n| +-----------------+-------------------------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`int`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_ULONG64ARRAY | Numpy | :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.uint64`) |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_ULONG64 + SPECTRUM)| Bytes | :py:obj:`bytes` |\n| +-----------------+-------------------------------------------------------------------------+\n| (DEV_ULONG64 + IMAGE) | ByteArray | :py:obj:`bytearray` |\n| +-----------------+-------------------------------------------------------------------------+\n| | String | :py:obj:`str` |\n| | | |\n| | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| +-----------------+-------------------------------------------------------------------------+\n| | List | :py:class:`list` <:py:obj:`int`> |\n| +-----------------+-------------------------------------------------------------------------+\n| | Tuple | :py:class:`tuple` <:py:obj:`int`> |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| DEVVAR_STRINGARRAY | | sequence<:py:obj:`str`> |\n| | | |\n| (DEV_STRING + SPECTRUM) | | (decoded with *latin-1*, aka *ISO-8859-1*) |\n| | | |\n| (DEV_STRING + IMAGE) | | |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| | | sequence of two elements: |\n| DEV_LONGSTRINGARRAY | | |\n| | | 0. :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.int32`) or |\n| | | sequence<:py:obj:`int`> |\n| | | 1. sequence<:py:obj:`str`> (decoded with *latin-1*, aka *ISO-8859-1*) |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n| | | sequence of two elements: |\n| DEV_DOUBLESTRINGARRAY | | |\n| | | 0. :py:class:`numpy.ndarray` (dtype= :py:obj:`numpy.float64`) or |\n| | | sequence<:py:obj:`int`> |\n| | | 1. sequence<:py:obj:`str`> (decoded with *latin-1*, aka *ISO-8859-1*) |\n+-------------------------+-----------------+-------------------------------------------------------------------------+\n```\n\nFor SPECTRUM and IMAGES the actual sequence object used depends on the context\nwhere the tango data is used.\n\n1. for properties the sequence is always a {py:class}`list`. Example:\n\n ```pycon\n >>> import tango\n >>> db = tango.Database()\n >>> s = db.get_property([\"TangoSynchrotrons\"])\n >>> print type(s)\n <type 'list'>\n ```\n\n2. for attribute/command values:\n\n - For non-string data types: {py:class}`numpy.ndarray`\n - For string data types:\n - {py:class}`tuple` \\<{py:class}`str`> for clients reading attributes\n - {py:class}`list` \\<{py:class}`str`> in attribute write and command handlers within devices\n\n(pytango-devenum-data-types)=", "text_sha1": "3095712ad300823559e94438b8ceca096f9d49d9"}
{"doc_id": "6536977f06cc026fc2dfec0a9b3c96c5661a8926", "path": "pytango-docsv10.1.12/api/data_types.md", "section": "DevEnum pythonic usage", "level": 2, "chunk_id": "1.0", "text": "## DevEnum pythonic usage\n\nWhen using regular tango DeviceProxy and AttributeProxy DevEnum is treated just\nlike in cpp tango (see [enumerated attributes](https://tango-controls.readthedocs.io/en/latest/How-To/development/cpp/how-to-enumerated-attribute.html#how-to-enumerated-attribute)\nfor more info). However, since PyTango >= 9.2.5 there is a more pythonic way of\nusing DevEnum data types if you use the {ref}`high level API <pytango-hlapi>`,\nboth in server and client side.\n\n:::{note}\nDevEnum is only support for device attributes, not for commands.\n:::\n\nIn server side you can use python {py:obj}`enum.IntEnum` class to deal with\nDevEnum attributes (here we use type hints, see {ref}`type-hint`, but we can also set\n`dtype=Noon` when defining the attribute - see earlier versions of this documentation):\n\n```{code-block} python\nimport time\nfrom enum import IntEnum\n\nfrom tango.server import Device, attribute, command\n\nclass Noon(IntEnum):\n AM = 0 # DevEnum's must start at 0\n PM = 1 # and increment by 1\n\nclass DisplayType(IntEnum):\n ANALOG = 0 # DevEnum's must start at 0\n DIGITAL = 1 # and increment by 1\n\nclass Clock(Device):\n display_type = DisplayType.ANALOG\n\n @attribute\n def time(self) -> float:\n return time.time()\n\n @attribute(max_dim_x=9)\n def gmtime(self) -> tuple[int]:\n return time.gmtime()\n\n @attribute\n def noon(self) -> Noon:\n time_struct = time.gmtime(time.time())\n return Noon.AM if time_struct.tm_hour < 12 else Noon.PM\n\n @attribute\n def display(self) -> DisplayType:\n return self.display_type\n\n @display.setter\n def display(self, display_type: int):\n # note that we receive an integer, not an enum instance,\n # so we have to convert that to an instance of our enum.\n self.display_type = DisplayType(display_type)\n\n @command(dtype_in=float, dtype_out=str)\n def ctime(self, seconds):\n \"\"\"\n Convert a time in seconds since the Epoch to a string in local time.\n This is equivalent to asctime(localtime(seconds)). When the time tuple\n is not present, current time as returned by localtime() is used.\n \"\"\"\n return time.ctime(seconds)\n\n @command\n def mktime(self, tupl: tuple[int]) -> float:\n return time.mktime(tuple(tupl))\n\nif __name__ == \"__main__\":\n Clock.run_server()\n```\n\nOn the client side you can also use a pythonic approach for using DevEnum attributes:\n\n```{code-block} python\nimport sys\nimport tango\n\nif len(sys.argv) != 2:\n print(\"must provide one and only one clock device name\")\n sys.exit(1)\n\nclock = tango.DeviceProxy(sys.argv[1])\nt = clock.time\ngmt = clock.gmtime\nnoon = clock.noon\ndisplay = clock.display\nprint(t)\nprint(gmt)\nprint(noon, noon.name, noon.value)\nif noon == noon.AM:\n print(\"Good morning!\")\nprint(clock.ctime(t))\nprint(clock.mktime(gmt))\nprint(display, display.name, display.value)\nclock.display = display.ANALOG\nclock.display = \"DIGITAL\" # you can use a valid string to set the value\nprint(clock.display, clock.display.name, clock.display.value)\ndisplay_type = type(display) # or even create your own IntEnum type\nanalog = display_type(0)\nclock.display = analog\nprint(clock.display, clock.display.name, clock.display.value)\nclock.display = clock.display.DIGITAL\nprint(clock.display, clock.display.name, clock.display.value)\n```\n\nExample output:\n\n```console\n$ python client.py test/clock/1\n1699433430.714272\n[2023 11 8 8 50 30 2 312 0]\n0 AM 0\nGood morning!\nWed Nov 8 09:50:30 2023\n1699429830.0\n0 ANALOG 0\n1 DIGITAL 1\n0 ANALOG 0\n1 DIGITAL 1\n```", "text_sha1": "cb0c9581e9901c9c68a90a0eb598edc8b1747068"}
{"doc_id": "8b777e189a21edffbb04dcdc20d0edb710c019d9", "path": "pytango-docsv10.1.12/api/database.md", "section": "Database API", "level": 1, "chunk_id": "0.0", "text": "# Database API\n\n```{eval-rst}\n.. currentmodule:: tango\n```\n\n```{eval-rst}\n.. autoclass:: tango.Database\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DbDatum\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DbDevExportInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DbDevExportInfos\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DbDevImportInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DbDevImportInfos\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DbDevInfo\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DbHistory\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DbServerInfo\n :members:\n```", "text_sha1": "19b72ac5788f096ee2a9c76b9af3dc0f46ce2b42"}
{"doc_id": "03cb06d89dc2579a3955b00299cbad8940f909e7", "path": "pytango-docsv10.1.12/api/encoded.md", "section": "Encoded API", "level": 1, "chunk_id": "0.0", "text": "# Encoded API\n\n*This feature is only possible since PyTango 7.1.4*\n\n```{eval-rst}\n.. currentmodule:: tango\n```\n\n```{eval-rst}\n.. autoclass:: tango.EncodedAttribute\n :members:\n```", "text_sha1": "bf15076c60fad0611092c0065f1a2c9773617bf2"}
{"doc_id": "8a2534bfb09dcb4d9b372e738803493a5ae03207", "path": "pytango-docsv10.1.12/api/exception.md", "section": "Exception definition", "level": 2, "chunk_id": "1.0", "text": "## Exception definition\n\nAll the exceptions that can be thrown by the underlying Tango C++ API are available\nin the PyTango python module. Hence a user can catch one of the following\nexceptions:\n\n> - {class}`DevFailed`\n> - {class}`ConnectionFailed`\n> - {class}`CommunicationFailed`\n> - {class}`WrongNameSyntax`\n> - {class}`NonDbDevice`\n> - {class}`WrongData`\n> - {class}`NonSupportedFeature`\n> - {class}`AsynCall`\n> - {class}`AsynReplyNotArrived`\n> - {class}`EventSystemFailed`\n> - {class}`NamedDevFailedList`\n> - {class}`DeviceUnlocked`\n\nWhen an exception is caught, the sys.exc_info() function returns a tuple of three\nvalues that give information about the exception that is currently being handled.\nThe values returned are (type, value, traceback).\nSince most functions don't need access to the traceback, the best solution is to\nuse something like exctype, value = sys.exc_info()\\[:2\\] to extract only the exception\ntype and value. If one of the Tango exceptions is caught, the exctype will be class\nname of the exception (DevFailed, .. etc) and the value a tuple of dictionary objects\nall of which containing the following kind of key-value pairs:\n\n- **reason**: a string describing the error type (more readable than the associated error code)\n- **desc**: a string describing in plain text the reason of the error.\n- **origin**: a string giving the name of the (C++ API) method which thrown the exception\n- **severity**: one of the strings WARN, ERR, PANIC giving severity level of the error.\n\n```\nimport tango", "text_sha1": "7bfdd00255cc4af50bcd4e8fb5e82e852276b9ae"}
{"doc_id": "8a2534bfb09dcb4d9b372e738803493a5ae03207", "path": "pytango-docsv10.1.12/api/exception.md", "section": "How to protect the script from exceptions raised by the Tango", "level": 1, "chunk_id": "2.0", "text": "# How to protect the script from exceptions raised by the Tango\ntry:\n # Get proxy on a non existing device should throw an exception\n device = tango.DeviceProxy(\"non/existing/device\")\nexcept DevFailed as df:\n print(\"Failed to create proxy to non/existing/device:\\n%s\" % df)\n```", "text_sha1": "818f4222f3d24d9d74b642fba6477c6237a452e6"}
{"doc_id": "8a2534bfb09dcb4d9b372e738803493a5ae03207", "path": "pytango-docsv10.1.12/api/exception.md", "section": "Throwing exception in a device server", "level": 2, "chunk_id": "3.0", "text": "## Throwing exception in a device server\n\nThe C++ {class}`~tango::Except` class with its most important methods have\nbeen wrapped to Python. Therefore, in a Python device server, you have the\nfollowing methods to throw, re-throw or print a Tango::DevFailed exception :\n\n- {meth}`~tango.Except.throw_exception` which is a static method\n- {meth}`~tango.Except.re_throw_exception` which is also a static method\n- {meth}`~tango.Except.print_exception` which is also a static method\n\nThe following code is an example of a command method requesting a command on a\nsub-device and re-throwing the exception in case of:\n\n```\ntry:\n dev.command_inout(\"SubDevCommand\")\nexcept tango.DevFailed as df:\n tango.Except.re_throw_exception(df,\n \"MyClass_CommandFailed\",\n \"Sub device command SubdevCommand failed\",\n \"Command()\")\n```\n\n```{eval-rst}\n\n:line 2: Send the command to the sub device in a try/catch block\n:line 4-6: Re-throw the exception and add a new level of information in the exception stack\n```", "text_sha1": "13f98238671b60dcd894b3e6abc432a51413775c"}
{"doc_id": "8a2534bfb09dcb4d9b372e738803493a5ae03207", "path": "pytango-docsv10.1.12/api/exception.md", "section": "Exception API", "level": 2, "chunk_id": "4.0", "text": "## Exception API\n\n```{eval-rst}\n.. autoclass:: tango.Except\n :show-inheritance:\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.DevError\n :show-inheritance:\n :members:\n```\n\n```{eval-rst}\n.. autoexception:: tango.DevFailed\n :show-inheritance:\n :members:\n```\n\n```{eval-rst}\n.. autoexception:: tango.ConnectionFailed\n :show-inheritance:\n\n This exception is thrown when a problem occurs during the connection\n establishment between the application and the device. The API is stateless.\n This means that DeviceProxy constructors filter most of the exception\n except for cases described in the following table.\n\n The desc DevError structure field allows a user to get more precise information. These informations are :\n\n **DB_DeviceNotDefined**\n The name of the device not defined in the database\n **API_CommandFailed**\n The device and command name\n **API_CantConnectToDevice**\n The device name\n **API_CorbaException**\n The name of the CORBA exception, its reason, its locality, its completed\n flag and its minor code\n **API_CantConnectToDatabase**\n The database server host and its port number\n **API_DeviceNotExported**\n The device name\n\n```\n\n```{eval-rst}\n.. autoexception:: tango.CommunicationFailed\n :show-inheritance:\n\n This exception is thrown when a communication problem is detected during\n the communication between the client application and the device server. It\n is a two levels Tango::DevError structure. In case of time-out, the DevError\n structures fields are:\n\n +-------+--------------------+-------------------------------------------------+----------+\n | Level | Reason | Desc | Severity |\n +=======+====================+=================================================+==========+\n | 0 | API_CorbaException | CORBA exception fields translated into a string | ERR |\n +-------+--------------------+-------------------------------------------------+----------+\n | 1 | API_DeviceTimedOut | String with time-out value and device name | ERR |\n +-------+--------------------+-------------------------------------------------+----------+\n\n For all other communication errors, the DevError structures fields are:\n\n +-------+-------------------------+----------------------------------------------------+----------+\n | Level | Reason | Desc | Severity |\n +=======+=========================+====================================================+==========+\n | 0 | API_CorbaException | CORBA exception fields translated into a string | ERR |\n +-------+-------------------------+----------------------------------------------------+----------+\n | 1 | API_CommunicationFailed | String with device, method, command/attribute name | ERR |\n +-------+-------------------------+----------------------------------------------------+----------+\n\n```\n\n```{eval-rst}\n.. autoexception:: tango.WrongNameSyntax\n :show-inheritance:\n```\n\nThis exception has only one level of Tango::DevError structure. The possible\nvalue for the reason field are :\n\n> **API_UnsupportedProtocol**\n>\n> : This error occurs when trying to build a DeviceProxy or an AttributeProxy\n> instance for a device with an unsupported protocol. Refer to the appendix\n> on device naming syntax to get the list of supported database modifier\n>\n> **API_UnsupportedDBaseModifier**\n>\n> : This error occurs when trying to build a DeviceProxy or an AttributeProxy\n> instance for a device/attribute with a database modifier unsupported.\n> Refer to the appendix on device naming syntax to get the list of\n> supported database modifier\n>\n> **API_WrongDe", "text_sha1": "a766f2b941d61b86626d9a5834bafdab83fb914e"}
{"doc_id": "8a2534bfb09dcb4d9b372e738803493a5ae03207", "path": "pytango-docsv10.1.12/api/exception.md", "section": "Exception API", "level": 2, "chunk_id": "4.1", "text": "viceNameSyntax**\n>\n> : This error occurs for all the other error in device name syntax. It is\n> thrown by the DeviceProxy class constructor.\n>\n> **API_WrongAttributeNameSyntax**\n>\n> : This error occurs for all the other error in attribute name syntax. It\n> is thrown by the AttributeProxy class constructor.\n>\n> **API_WrongWildcardUsage**\n>\n> : This error occurs if there is a bad usage of the wildcard character\n\n```{eval-rst}\n.. autoexception:: tango.NonDbDevice\n :show-inheritance:\n\n This exception has only one level of Tango::DevError structure. The reason\n field is set to API_NonDatabaseDevice. This exception is thrown by the API\n when using the DeviceProxy or AttributeProxy class database access for\n non-database device.\n```\n\n```{eval-rst}\n.. autoexception:: tango.WrongData\n :show-inheritance:\n\n This exception has only one level of Tango::DevError structure.\n The possible value for the reason field are :\n\n **API_EmptyDbDatum**\n This error occurs when trying to extract data from an empty DbDatum\n object\n **API_IncompatibleArgumentType**\n This error occurs when trying to extract data with a type different\n than the type used to send the data\n **API_EmptyDeviceAttribute**\n This error occurs when trying to extract data from an empty\n DeviceAttribute object\n **API_IncompatibleAttrArgumentType**\n This error occurs when trying to extract attribute data with a type\n different than the type used to send the data\n **API_EmptyDeviceData**\n This error occurs when trying to extract data from an empty DeviceData\n object\n **API_IncompatibleCmdArgumentType**\n This error occurs when trying to extract command data with a type\n different than the type used to send the data\n```\n\n```{eval-rst}\n.. autoexception:: tango.NonSupportedFeature\n :show-inheritance:\n\n This exception is thrown by the API layer when a request to a feature\n implemented in Tango device interface release n is requested for a device\n implementing Tango device interface n-x. There is one possible value for\n the reason field which is API_UnsupportedFeature.\n```\n\n```{eval-rst}\n.. autoexception:: tango.AsynCall\n :show-inheritance:\n\n This exception is thrown by the API layer when a the asynchronous model id\n badly used. This exception has only one level of Tango::DevError structure.\n The possible value for the reason field are :\n\n **API_BadAsynPollId**\n This error occurs when using an asynchronous request identifier which is not\n valid any more.\n **API_BadAsyn**\n This error occurs when trying to fire callback when no callback has been\n previously registered\n **API_BadAsynReqType**\n This error occurs when trying to get result of an asynchronous request with\n an asynchronous request identifier returned by a non-coherent asynchronous\n request (For instance, using the asynchronous request identifier returned\n by a command_inout_asynch() method with a read_attribute_reply() attribute).\n```\n\n```{eval-rst}\n.. autoexception:: tango.AsynReplyNotArrived\n :show-inheritance:\n\n This exception is thrown by the API layer when:\n\n - a request to get asynchronous reply is made and the reply is not yet arrived\n - a blocking wait with timeout for asynchronous reply is made and the timeout expired.\n\n There is one possible value for the reason field which is API_AsynReplyNotArrived.\n```\n\n```{eval-rst}\n.. autoexception:: tango.EventSystemFailed\n :show-inheritance:\n\n This exception is thrown by the API layer when subscribing or unsubscribing\n from an event failed. This exception has only one level of Tango::DevError", "text_sha1": "5c29a450887ffd0f96da56ae7fe8b86fe5770e8e"}
{"doc_id": "8a2534bfb09dcb4d9b372e738803493a5ae03207", "path": "pytango-docsv10.1.12/api/exception.md", "section": "Exception API", "level": 2, "chunk_id": "4.2", "text": "structure. The possible value for the reason field are :\n\n **API_NotificationServiceFailed**\n This error occurs when the subscribe_event() method failed trying to\n access the CORBA notification service\n **API_EventNotFound**\n This error occurs when you are using an incorrect event_id in the\n unsubscribe_event() method\n **API_InvalidArgs**\n This error occurs when NULL pointers are passed to the subscribe or\n unsubscribe event methods\n **API_MethodArgument**\n This error occurs when trying to subscribe to an event which has already\n been subsribed to\n **API_DSFailedRegisteringEvent**\n This error means that the device server to which the device belongs to\n failed when it tries to register the event. Most likely, it means that\n there is no event property defined\n **API_EventNotFound**\n Occurs when using a wrong event identifier in the unsubscribe_event\n method\n\n```\n\n```{eval-rst}\n.. autoexception:: tango.DeviceUnlocked\n :show-inheritance:\n\n This exception is thrown by the API layer when a device locked by the\n process has been unlocked by an admin client. This exception has two levels\n of Tango::DevError structure. There is only possible value for the reason\n field which is\n\n **API_DeviceUnlocked**\n The device has been unlocked by another client (administration client)\n\n The first level is the message reported by the Tango kernel from the server\n side. The second layer is added by the client API layer with informations on\n which API call generates the exception and device name.\n```\n\n```{eval-rst}\n.. autoexception:: tango.NotAllowed\n :show-inheritance:\n\n```\n\n```{eval-rst}\n.. autoexception:: tango.NamedDevFailedList\n :show-inheritance:\n\n This exception is only thrown by the DeviceProxy::write_attributes()\n method. In this case, it is necessary to have a new class of exception\n to transfer the error stack for several attribute(s) which failed during\n the writing. Therefore, this exception class contains for each attributes\n which failed :\n\n - The name of the attribute\n - Its index in the vector passed as argumen tof the write_attributes() method\n - The error stack\n```", "text_sha1": "484154f5dbec9f3710aafdba1f7d574a9cbfc7a2"}
{"doc_id": "5c7bf0c8f70743efdb17db2646aa0dca51f0cdbf", "path": "pytango-docsv10.1.12/api/other.md", "section": "Enumerations", "level": 2, "chunk_id": "1.0", "text": "## Enumerations\n\n```{eval-rst}\n.. autoclass:: tango.LockerLanguage\n```\n\n```{eval-rst}\n.. autoclass:: tango.CmdArgType\n```\n\n```{eval-rst}\n.. autoclass:: tango.MessBoxType\n```\n\n```{eval-rst}\n.. autoclass:: tango.PollObjType\n```\n\n```{eval-rst}\n.. autoclass:: tango.PollCmdCode\n```\n\n```{eval-rst}\n.. autoclass:: tango..SerialModel\n```\n\n```{eval-rst}\n.. autoclass:: tango.AttReqType\n```\n\n```{eval-rst}\n.. autoclass:: tango.LockCmdCode\n```\n\n```{eval-rst}\n.. autoclass:: tango.LogLevel\n```\n\n```{eval-rst}\n.. autoclass:: tango.LogTarget\n```\n\n```{eval-rst}\n.. autoclass:: tango.EventType\n```\n\n```{eval-rst}\n.. autoclass:: tango.KeepAliveCmdCode\n```\n\n```{eval-rst}\n.. autoclass:: tango.AccessControlType\n```\n\n```{eval-rst}\n.. autoclass:: tango.asyn_req_type\n```\n\n```{eval-rst}\n.. autoclass:: tango.cb_sub_model\n```\n\n```{eval-rst}\n.. autoclass:: tango.AttrQuality\n```\n\n```{eval-rst}\n.. autoclass:: tango.AttrWriteType\n```\n\n```{eval-rst}\n.. autoclass:: tango.AttrDataFormat\n```\n\n```{eval-rst}\n.. autoclass:: tango.DevSource\n```\n\n```{eval-rst}\n.. autoclass:: tango.ErrSeverity\n```\n\n```{eval-rst}\n.. autoclass:: tango.DevState\n```\n\n```{eval-rst}\n.. autoclass:: tango.DispLevel\n```\n\n```{eval-rst}\n.. autoclass:: tango.GreenMode\n\n```", "text_sha1": "ab5ca1232d3c282f31cf90271a21e31853b1c880"}
{"doc_id": "5c7bf0c8f70743efdb17db2646aa0dca51f0cdbf", "path": "pytango-docsv10.1.12/api/other.md", "section": "Other classes", "level": 2, "chunk_id": "2.0", "text": "## Other classes\n\n```{eval-rst}\n.. autoclass:: tango.Release\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.TimeVal\n :members:\n\n .. rubric:: Constructors\n\n .. py:method:: __init__(self)\n :no-index:\n\n Default constructor; all fields set to 0.\n\n .. py:method:: __init__(self, tv_sec: int, tv_usec: int, tv_nsec: int)\n :no-index:\n\n Create a TimeVal by specifying all three members.\n\n .. py:method:: __init__(self, time: float)\n :no-index:\n\n Create a TimeVal from time in seconds since epoch (e.g. time.time()).\n\n .. py:method:: __init__(self, time: datetime.datetime)\n :no-index:\n\n Create a TimeVal from time in datetime.datetime format (e.g. datetime.datetime.now()).\n```\n\n```{eval-rst}\n.. autoclass:: tango.TimedAttrData\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.TimedCmdData\n :members:\n```", "text_sha1": "73fea7839bcd7e319088fccdfc6effffd7836ee8"}
{"doc_id": "982fc673673741752783f4af132863238e7fbfd3", "path": "pytango-docsv10.1.12/api/server_api/attribute.md", "section": "Attribute Configs", "level": 2, "chunk_id": "6.0", "text": "## Attribute Configs\n\n```{eval-rst}\n.. autoclass:: tango.AttributeConfig\n :members:\n :undoc-members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.AttributeConfig_2\n :members:\n :undoc-members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.AttributeConfig_3\n :members:\n :undoc-members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.AttributeConfig_5\n :members:\n :undoc-members:\n```", "text_sha1": "43e834054c626754b970c66673d50839799e7ba5"}
{"doc_id": "ea4e700e88801cd5fa5b5f170ae357ce96130513", "path": "pytango-docsv10.1.12/api/server_api/server.md", "section": "High level server API", "level": 1, "chunk_id": "0.0", "text": "# High level server API\n\n```{eval-rst}\n.. automodule:: tango.server\n```\n\n```{eval-rst}\n.. hlist::\n\n * :class:`~tango.server.Device`\n * :class:`~tango.server.attribute`\n * :class:`~tango.server.command`\n * :class:`~tango.server.device_property`\n * :class:`~tango.server.class_property`\n * :func:`~tango.server.run`\n * :func:`~tango.server.server_run`\n```\n\nThis module provides a high level device server API. It implements\n[TEP1](#pytango-TEP1). It exposes an easier API for developing a Tango\ndevice server.\n\nHere is a simple example on how to write a *Clock* device server using the\nhigh level API:\n\n```\nimport time\nfrom tango.server import run\nfrom tango.server import Device\nfrom tango.server import attribute, command\n\nclass Clock(Device):\n\n time = attribute()\n\n def read_time(self):\n return time.time()\n\n @command(dtype_in=str, dtype_out=str)\n def strftime(self, format):\n return time.strftime(format)\n\nif __name__ == \"__main__\":\n run((Clock,))\n```\n\nHere is a more complete example on how to write a *PowerSupply* device server\nusing the high level API. The example contains:\n\n1. device description (via docstring), which user can get later as DeviceProxy.description()\n2. default state DevState.ON and default status \"Device is current supply mode\"\n3. a read-only double scalar attribute called *voltage*\n4. a read/write double scalar expert attribute *current*\n5. a read-only double image attribute called *noise*\n6. a *ramp* command\n7. a *host* device property\n8. a *port* class property\n\n```{code-block} python\n:linenos: true\n\nfrom time import time\nfrom numpy.random import random_sample\n\nfrom tango import AttrQuality, AttrWriteType, DevState, DispLevel\nfrom tango.server import Device, attribute, command\nfrom tango.server import class_property, device_property\n\nclass PowerSupply(Device):\n \"\"\"PyTango example of PowerSuppy device.\"\"\"\n\n # alternative way to add device description (see note below)\n DEVICE_CLASS_DESCRIPTION = \"PyTango example of PowerSuppy device.\"\n\n DEVICE_CLASS_INITIAL_STATUS = \"Device is in current supply mode\"\n DEVICE_CLASS_INITIAL_STATE = DevState.ON\n\n voltage = attribute()\n\n current = attribute(label=\"Current\", dtype=float,\n display_level=DispLevel.EXPERT,\n access=AttrWriteType.READ_WRITE,\n unit=\"A\", format=\"8.4f\",\n min_value=0.0, max_value=8.5,\n min_alarm=0.1, max_alarm=8.4,\n min_warning=0.5, max_warning=8.0,\n fget=\"get_current\", fset=\"set_current\",\n doc=\"the power supply current\")\n\n noise = attribute(label=\"Noise\", dtype=((float,),),\n max_dim_x=1024, max_dim_y=1024,\n fget=\"get_noise\")\n\n host = device_property(dtype=str)\n port = class_property(dtype=int, default_value=9788)\n\n def read_voltage(self):\n self.info_stream(f\"Get voltage({self.host}, {self.port})\")\n return 10.0\n\n def get_current(self):\n return 2.3456, time(), AttrQuality.ATTR_CHANGING\n\n def set_current(self, current):\n self.info_stream(f\"Current set to {current}\")\n\n def get_noise(self):\n return random_sample((1024, 1024))\n\n @command(dtype_in=float)\n def ramp(self, value):\n self.info_stream(f\"Ramp up requested: {value} seconds\")\n\nif __name__ == \"__main__\":\n PowerSupply.run_server()\n```\n\n*Pretty cool, uh?*\n\n:::{note}\nthe device description can be added either by class docstring or by DEVICE_CLASS_DESCRIPTION class member, the latter has priority over the docstring.\nThe important difference is that DEVICE_CLASS_DESCRIPTION will be inherited by child classes, while the docstring will not be.\n:::\n\n(pytango-hlapi-datatypes)=\n\n```{rubric} Data types\n```\n\nWhen declaring attributes, p", "text_sha1": "ef2700f1a4d33a38e0ca3b6cb7a68736fee8f30d"}
{"doc_id": "ea4e700e88801cd5fa5b5f170ae357ce96130513", "path": "pytango-docsv10.1.12/api/server_api/server.md", "section": "High level server API", "level": 1, "chunk_id": "0.1", "text": "roperties or commands, one of the most important\ndetails is the data type. It is given by the keyword argument *dtype*.\nIn order to provide a more *pythonic* interface, this argument is not restricted\nto the {obj}`~tango.CmdArgType` options.\n\nFor example, to define a *SCALAR* {obj}`~tango.CmdArgType.DevLong`\nattribute you have several possibilities:\n\n1. {obj}`int`\n2. 'int'\n3. 'int64'\n4. {obj}`tango.CmdArgType.DevLong64`\n5. 'DevLong64'\n6. {obj}`numpy.int64`\n\nTo define a *SPECTRUM* attribute simply wrap the scalar data type in any\npython sequence:\n\n- using a *tuple*: `` (:obj:`int`,) `` or\n- using a *list*: `` [:obj:`int`] `` or\n- any other sequence type\n\nTo define an *IMAGE* attribute simply wrap the scalar data type in any\npython sequence of sequences:\n\n- using a *tuple*: `` ((:obj:`int`,),) `` or\n- using a *list*: `` [[:obj:`int`]] `` or\n- any other sequence type\n\nBelow is the complete table of equivalences.\n\n| dtype argument | converts to tango type |\n| --------------------------- | ------------------------- |\n| `None` | `DevVoid` |\n| `'None'` | `DevVoid` |\n| `DevVoid` | `DevVoid` |\n| `'DevVoid'` | `DevVoid` |\n| `DevState` | `DevState` |\n| `'DevState'` | `DevState` |\n| {py:obj}`bool` | `DevBoolean` |\n| `'bool'` | `DevBoolean` |\n| `'boolean'` | `DevBoolean` |\n| `DevBoolean` | `DevBoolean` |\n| `'DevBoolean'` | `DevBoolean` |\n| {py:obj}`numpy.bool_` | `DevBoolean` |\n| `'char'` | `DevUChar` |\n| `'chr'` | `DevUChar` |\n| `'byte'` | `DevUChar` |\n| `chr` | `DevUChar` |\n| `DevUChar` | `DevUChar` |\n| `'DevUChar'` | `DevUChar` |\n| {py:obj}`numpy.uint8` | `DevUChar` |\n| `'int16'` | `DevShort` |\n| `DevShort` | `DevShort` |\n| `'DevShort'` | `DevShort` |\n| {py:obj}`numpy.int16` | `DevShort` |\n| `'uint16'` | `DevUShort` |\n| `DevUShort` | `DevUShort` |\n| `'DevUShort'` | `DevUShort` |\n| {py:obj}`numpy.uint16` | `DevUShort` |\n| `'int32'` | `DevLong` |\n| `DevLong` | `DevLong` |\n| `'DevLong'` | `DevLong` |\n| {py:obj}`numpy.int32` | `DevLong` |\n| `'uint32'` | `DevULong` |\n| `DevULong` | `DevULong` |\n| `'DevULong'` | `DevULong` |\n| {py:obj}`numpy.uint32` | `DevULong` |\n| {py:obj}`int` | `DevLong64` |\n| `'int'` | `DevLong64` |\n| `'int64'` | `DevLong64` |\n| `DevLong64` | `DevLong64` |\n| `'DevLong64'` | `DevLong64` |\n| {py:obj}`numpy.int64` | `DevLong64` |\n| `'uint'` | `DevULong64` |\n| `'uint64'` | `DevULong64` |\n| `DevULong64` | `DevULong64` |\n| `'DevULong64'` | `DevULong64` |\n| {py:obj}`numpy.uint64` | `DevULong64` |\n| `'float32'` | `DevFloat` |\n| `DevFloat` | `DevFloat` |\n| `'DevFloat'` | `DevFloat` |\n| {py:obj}`numpy.float32` | `DevFloat` |\n| {py:obj}`float` | `DevDouble` |\n| `'double'` | `DevDouble` |\n| `'float'` | `DevDouble` |\n| `'float64'` | `DevDouble` |\n| `DevDouble` | `DevDouble` |\n| `'DevDouble'` | `DevDouble` |\n| {py:obj}`numpy.float64` | `DevDouble` |\n| {py:obj}`str` | `DevString` |\n| `'str'` | `DevString` |\n| `'string'` | `DevString` |\n| `'text'` | `DevString` |\n| `DevString` | `DevString` |\n| `'DevString'` | `DevString` |\n| {py:obj}`bytearray` | `DevEncoded` |\n| `'bytearray'` | `DevEncoded` |\n| `'bytes'` | `DevEncoded` |\n| `DevEncoded` | `DevEncoded` |\n| `'DevEncoded'` | `DevEncoded` |\n| `DevVarBooleanArray` | `DevVarBooleanArray` |\n| `'DevVarBooleanArray'` | `DevVarBooleanArray` |\n| `DevVarCharArray` | `DevVarCharArray` |\n| `'DevVarCharArray'` | `DevVarCharArray` |\n| `DevVarShortArray` | `DevVarShortArray` |\n| `'DevVarShortArray'` | `DevVarShortArray` |\n| `DevVarLongArray` | `DevVarLongArray` |\n| `'DevVarLongArray'` | `DevVarLongArray` |\n| `De", "text_sha1": "d4f2c355c1b1b61987561cf29964d65a7add2931"}
{"doc_id": "ea4e700e88801cd5fa5b5f170ae357ce96130513", "path": "pytango-docsv10.1.12/api/server_api/server.md", "section": "High level server API", "level": 1, "chunk_id": "0.2", "text": "vVarLong64Array` | `DevVarLong64Array` |\n| `'DevVarLong64Array'` | `DevVarLong64Array` |\n| `DevVarULong64Array` | `DevVarULong64Array` |\n| `'DevVarULong64Array'` | `DevVarULong64Array` |\n| `DevVarFloatArray` | `DevVarFloatArray` |\n| `'DevVarFloatArray'` | `DevVarFloatArray` |\n| `DevVarDoubleArray` | `DevVarDoubleArray` |\n| `'DevVarDoubleArray'` | `DevVarDoubleArray` |\n| `DevVarUShortArray` | `DevVarUShortArray` |\n| `'DevVarUShortArray'` | `DevVarUShortArray` |\n| `DevVarULongArray` | `DevVarULongArray` |\n| `'DevVarULongArray'` | `DevVarULongArray` |\n| `DevVarStringArray` | `DevVarStringArray` |\n| `'DevVarStringArray'` | `DevVarStringArray` |\n| `DevVarLongStringArray` | `DevVarLongStringArray` |\n| `'DevVarLongStringArray'` | `DevVarLongStringArray` |\n| `DevVarDoubleStringArray` | `DevVarDoubleStringArray` |\n| `'DevVarDoubleStringArray'` | `DevVarDoubleStringArray` |\n\n```{eval-rst}\n.. autoclass:: Device\n :show-inheritance:\n :inherited-members:\n :members:\n```\n\n```{eval-rst}\n.. autoclass:: attribute\n```\n\n```{eval-rst}\n.. autofunction:: command\n```\n\n```{eval-rst}\n.. autoclass:: device_property\n```\n\n```{eval-rst}\n.. autoclass:: class_property\n```\n\n```{eval-rst}\n.. autofunction:: run\n```\n\n```{eval-rst}\n.. autofunction:: server_run\n```", "text_sha1": "b12c6dd83525922d73ba0692ec503483f2eeef6d"}
{"doc_id": "201398a7337c4cf70ed02b014a81ba5af5ba5705", "path": "pytango-docsv10.1.12/api/server_api/util.md", "section": "Util", "level": 1, "chunk_id": "0.0", "text": "# Util\n\n```{eval-rst}\n.. currentmodule:: tango\n```\n\n```{eval-rst}\n.. autoclass:: tango.Util\n :members:\n :inherited-members:\n```\n\n```{eval-rst}\n.. autoclass:: tango.SubDevDiag\n :members:\n :inherited-members:\n```", "text_sha1": "1bca5ea1b4edfaadb58f5c32d6b5b6e64c67aa19"}
{"doc_id": "2afa0cc0d9e54ee8cea9287286b103033c10d8a2", "path": "pytango-docsv10.1.12/api/test_utilities.md", "section": "The Test Utilities API", "level": 1, "chunk_id": "0.0", "text": "# The Test Utilities API\n\n```{eval-rst}\n.. autofunction:: tango.test_context.get_server_port_via_pid\n```\n\n```{eval-rst}\n.. autofunction:: tango.test_utils.wait_for_proxy\n```\n\n```{eval-rst}\n.. autofunction:: tango.test_utils.wait_for_nodb_proxy_via_pid\n```", "text_sha1": "f434ddc280ff46c007cef11d0eac7ded466abd44"}
{"doc_id": "2afa0cc0d9e54ee8cea9287286b103033c10d8a2", "path": "pytango-docsv10.1.12/api/test_utilities.md", "section": "Device Test Context API", "level": 1, "chunk_id": "1.0", "text": "# Device Test Context API\n\nSee [Device Test Context Classes API](#testing-test-context) for details of the classes that can be used to\nlaunch a device server for testing.", "text_sha1": "413929eba39f7c4dfdc0869d1c7c0db6727a3b57"}
{"doc_id": "51930ef4325fd54307ff623c67ff35983d0b65ce", "path": "pytango-docsv10.1.12/api/utilities.md", "section": "The Utilities API", "level": 1, "chunk_id": "0.0", "text": "# The Utilities API\n\n```{eval-rst}\n.. currentmodule:: tango.utils\n```\n\n```{eval-rst}\n.. autoclass:: tango.utils.EventCallback\n :members:\n :undoc-members:\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.get_enum_labels\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_pure_str\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_seq\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_non_str_seq\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_integer\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_number\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_bool\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_scalar_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_array_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_numerical_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_int_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_float_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_bool_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_binary_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.is_str_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.obj_2_str\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.seqStr_2_obj\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.scalar_to_array_type\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.get_home\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.requires_pytango\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.requires_tango\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.set_telemetry_tracer_provider_factory\n```\n\n```{eval-rst}\n.. autofunction:: tango.utils.get_telemetry_tracer_provider_factory\n```", "text_sha1": "ff25424d689d6b9ecf5f06a1bd6824629c564bb8"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "PyTango Training Material", "level": 1, "chunk_id": "0.0", "text": "# PyTango Training Material\n\nThis folder includes example scripts for using PyTango as a client and a server.\nIt is useful to refer to during training exercises.", "text_sha1": "e5cdb83e2127d26c95de57b5b9d821a062b96e9f"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Acknowledgments", "level": 2, "chunk_id": "1.0", "text": "## Acknowledgments\n\nPortions of the source code are derived from work by multiple authors:\n- https://github.com/vxgmichel\n- https://github.com/tiagocoutinho\n- https://github.com/ajoubertza\n- https://github.com/lorenzopivetta\n\nThese repos were used:\n- https://github.com/vxgmichel/icalepcs-workshop\n- https://github.com/ajoubertza/icalepcs-workshop", "text_sha1": "bf49ba92b600d6c48fb6e05b4b1c613ba8a17e56"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Setup of the Tango Development Environment", "level": 2, "chunk_id": "2.0", "text": "## Setup of the Tango Development Environment\n\nA simple Docker compose environment is useful for executing these scripts.\n\nWe use existing docker images for database, Tango Database server, TangoTest server and ipython/itango CLI.\nThey are from the [Square Kilometre Array Organisation](https://www.skatelescope.org) (SKAO) project.\n\nContainer services:\n- **tangodb**: MariaDB database\n- **databaseds**: Database Device Server, `sys/database/2`\n- **tangotest**: TangoTest Device Server: `sys/tg_test/1`\n- **cli**: Python command line tools, with this folder as a volume mount in `/training`", "text_sha1": "6cdd78ef80ecdfa3cb2dc0a837a0588cb2865480"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Docker network", "level": 3, "chunk_id": "3.0", "text": "### Docker network\nThe docker-compose file requires a Docker network to be created, since `host`\nnetworking is not supported on MacOS:\n\n```commandline\ndocker network create pytango-training-net\n```\n\nThe network can be removed, when no longer required:\n```commandline\ndocker network rm pytango-training-net\n```", "text_sha1": "f8201b5db7e238f3ccd79e94591de7e495f2e952"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Starting and stopping the services", "level": 3, "chunk_id": "4.0", "text": "### Starting and stopping the services\n\nFrom the folder containing `docker-compose.yml`, the services can be started by executing:\n\n```commandline\ndocker-compose up\n```\n\nPush CTRL+C to stop.", "text_sha1": "14f8b98eb8fc35546b33d88edc5260eed7bba653"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Start an ipython session", "level": 3, "chunk_id": "6.0", "text": "### Start an ipython session\n\n```shell\ndocker-compose exec cli ipython3\n\nPython 3.7.3 (default, Jan 22 2021, 20:04:44)\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.21.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: import tango\n\nIn [2]: print(tango.utils.info())\nPyTango 9.3.3 (9, 3, 3)\nPyTango compiled with:\n Python : 3.7.3\n Numpy : 1.19.2\n Tango : 9.3.4\n Boost : 1.67.0\n\nPyTango runtime is:\n Python : 3.7.3\n Numpy : 1.19.2\n Tango : 9.3.4\n\nPyTango running on:\nuname_result(system='Linux', node='86032deafb5a', release='4.19.121-linuxkit', version='#1 SMP Thu Jan 21 15:36:34 UTC 2021', machine='x86_64', processor='')\n```", "text_sha1": "45606db6651d1f49961b08dcf373fc69855b3a84"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Start an itango session", "level": 3, "chunk_id": "7.0", "text": "### Start an itango session\n\n```shell\ndocker-compose exec cli itango3\n\nITango 9.3.3 -- An interactive Tango client.\n\nRunning on top of Python 3.7.3, IPython 7.21 and PyTango 9.3.3\n\nhelp -> ITango's help system.\nobject? -> Details about 'object'. ?object also works, ?? prints more.\n\nIPython profile: tango\n\nhint: Try typing: mydev = Device(\"<tab>\n\nIn [1]: dev = Device(\"sys/tg_test/1\")\n\nIn [2]: dev.ping()\nOut[2]: 552\n\nIn [3]: dev.double_scalar\nOut[3]: -57.588745922974105\n```", "text_sha1": "2c264dbe8d84b5c081fd441b04789064213e8a8a"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Register and run a new device", "level": 3, "chunk_id": "8.0", "text": "### Register and run a new device\n\nStart the device:\n```shell\ndocker-compose exec cli bash\n\ntango@c5f6dc31dc6b:/training$ cd server/\ntango@c5f6dc31dc6b:/training/server$ ./ps0a.py test\nThe device server PowerSupply/test is not defined in database. Exiting!\ntango@c5f6dc31dc6b:/training/server$ tango_admin --add-server PowerSupply/test PowerSupply train/ps/1\ntango@c5f6dc31dc6b:/training/server$ ./ps0a.py test\nReady to accept request\n```\n\nWhile that is running, connect a `DeviceProxy` to it from another ipython session:\n```shell\ndocker-compose exec cli ipython3\n\nPython 3.7.3 (default, Jan 22 2021, 20:04:44)\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.21.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: import tango\n\nIn [2]: dp = tango.DeviceProxy(\"train/ps/1\")\n\nIn [3]: dp.ping()\nOut[3]: 318\n\nIn [4]: dp.voltage\nOut[4]: 1.23\n\n```", "text_sha1": "d49eeda273c733cac51f5b76adabe8b29641a68c"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Run the power supply simulator, and a device that uses it", "level": 3, "chunk_id": "9.0", "text": "### Run the power supply simulator, and a device that uses it\n\nEnsure the gevent package is installed:\n```shell\ndocker-compose exec cli pip install gevent\n\nDefaulting to user installation because normal site-packages is not writeable\n...\nSuccessfully installed gevent-21.1.2 greenlet-1.1.0 zope.event-4.5.0 zope.interface-5.4.0\n```\n\nStart the power supply simulator:\n```shell\ndocker-compose exec cli /training/server/ps-simulator.py\n\nINFO:root:starting simulator...\nINFO:simulator.45000:simulator listenning on ('', 45000)!\n```\n\nStart the power supply device:\n```shell\ndocker-compose exec cli /training/server/ps1.py test\n\nReady to accept request\n```\n\nWhile that is running, connect to it from another ipython session:\n```shell\ndocker-compose exec cli ipython3\n\nPython 3.7.3 (default, Jan 22 2021, 20:04:44)\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.21.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: import tango\n\nIn [2]: dp = tango.DeviceProxy(\"train/ps/1\")\n\nIn [3]: dp.voltage\nOut[3]: 0.1\n\nIn [4]: dp.calibrate()\n\nIn [5]:\n```", "text_sha1": "c3a313a5c5425469157bf208a5908937c538e2c4"}
{"doc_id": "fb80bc1fdb99bc7c03b974b65b56770b0a2ccce5", "path": "pytango-docsv10.1.12/examples/training/README.md", "section": "Webinars", "level": 2, "chunk_id": "10.0", "text": "## Webinars\n\nMore details of the webinars can be found online.\n- 4th Tango Kernel webinar - PyTango:\n https://www.tango-controls.org/community/news/2021/06/10/4th-tango-kernel-webinar-pytango/", "text_sha1": "65e0d538bc2e0a7f8a0d09f07aa03010a1497173"}
{"doc_id": "5610aadcb04026e7c92ec08698b365c064bb0a9f", "path": "pytango-docsv10.1.12/how-to/databaseds.md", "section": "PyTango Database Device Server", "level": 1, "chunk_id": "0.0", "text": "# PyTango Database Device Server\n\nThe Tango Database device (usually `sys/database/2`) is what all other\ndevices use to get their configuration and to coordinate with each\nother. It must be running in order for a Tango control system to work.\n\nThe standard Database device server is implemented in C++ and requires\na running MySQL or MariaDB server to operate, which means it can be\nchallenging to set up.\n\nPyTango contains its own Database implementation, which conforms to the\nC++ one and should work as a drop-in replacement. It stores data using\n`sqlite3` so it has no external dependencies. It can be useful for a\nlocal development environment, CI testing and, eventually, perhaps\neven a small control system setup.\n\n:::{warning}\nThis implementation is in an experimental state, and has not\nbeen extensively tested for compatibility or for performance.\nDon't use it for anything mission critical!\n:::\n\nTo run it:\n\n```console\n$ TANGO_HOST=localhost:11000 python -m tango.databaseds.database 2\n```\n\nNow you should be able to start Tango devices and use tools like Jive,\njust make sure to set `TANGO_HOST=localhost:11000`.\n\nThe sqlite3 database is stored in your current working directory, as\n`tango_database.db`. To start over from scratch, just remove this file.\n\nThe port number can be selected freely, but 10000 is the standard\nTango port, so choose another one if you need to run in parallel with\nan existing control system.", "text_sha1": "fabde34d30962a2d452268d2a49a59f7308a3603"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "How to Contribute", "level": 1, "chunk_id": "0.0", "text": "# How to Contribute\n\nEveryone is welcome to contribute to the PyTango project.\nIf you don't feel comfortable writing core PyTango, we are looking for contributors to documentation or/and tests.", "text_sha1": "1dacc57723f4e2822aaf136d12c42daab71fd483"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Report a bug", "level": 2, "chunk_id": "1.0", "text": "## Report a bug\n\nBugs can be reported as issues in [PyTango repository](https://gitlab.com/tango-controls/pytango/issues).\n\nIt is helpful if you include the PyTango version information in your issue's description.\nIt can be a dump of:\n\n```console\n$ python -c \"import tango; print(tango.utils.info())\"\n```", "text_sha1": "a16d9292076156e522bffe56ddd7eb1016991563"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Workflow", "level": 2, "chunk_id": "2.0", "text": "## Workflow\n\nA Git feature branch workflow is used. More details can be seen in this [tutorial].\nGood practices:\n\n- For commit messages the first line should be short (50 chars or less) and contain a summary\n of all changes. Provide more detail in additional paragraphs unless the change is trivial.\n- Merge requests (MRs) should be ALWAYS made to the `develop` branch.", "text_sha1": "e10d5ff23c6f608e13a1070ae89a55da1d8bd806"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "MyST and Sphinx", "level": 2, "chunk_id": "3.0", "text": "## MyST and Sphinx\n\nDocumentation is written in [MyST], a rich and extensible flavour of Markdown, and built with [Sphinx] - it's easy to contribute.\nIt also uses [autodoc] importing docstrings from tango package.\n\n:::{note}\nDocstrings still need to be written in [reStructuredText]\n:::\n\nTo test the docs locally with [pixi] (see [Using pixi for developement](#pixi-for-development)):\n\n```console\n$ cd /path/to/pytango\n$ pixi run doc\n```\n\nThere is also a `pixi run doc_no_cache` option to rebuild the docs completely. This is useful when\nthe only change is in a docstring, and Sphinx is not picking it up.\n\nAfter building, open the `build/sphinx/index.html` page in your browser.\n\nWhen working on the documentation, you can run `pixi run doc_live` to rebuild Sphinx documentation on changes, with hot reloading in the browser using [sphinx-autobuild](https://github.com/sphinx-doc/sphinx-autobuild#readme).", "text_sha1": "5b5ea15377c5d3f008e33c49c2bbdfddd8f95ae7"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Source code standard", "level": 2, "chunk_id": "4.0", "text": "## Source code standard\n\nAll code should be [PEP8] compatible. We have set up checking code quality with\n[pre-commit] which runs [ruff], a Python linter written in Rust. `pre-commit` is\nrun as first job in every gitlab-ci pipeline and will fail if errors are detected.\n\nIt is recommended to install [pre-commit] locally to check code quality on every commit,\nbefore to push to GitLab. This is a one time operation:\n\n- Install [pre-commit]. [pipx] is a good way if you use it.\n Otherwise, see the [official documentation](https://pre-commit.com/#install).\n- Run `pre-commit install` at the root of your `pytango` repository.\n\nThat's it. `pre-commit` will now run automatically on every commit.\nIf errors are reported, the commit will be aborted.\nYou should fix them and try to commit again.\n\nNote that you can also configure your editor to run `ruff`.\nSee [ruff README](https://github.com/charliermarsh/ruff#editor-integrations).\n\n(pixi-for-development)=", "text_sha1": "9f2f2661c720e0b7b16dd0c0322eb8a26520c0cb"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Using pixi for development", "level": 2, "chunk_id": "5.0", "text": "## Using pixi for development\n\nIf you like to be at the forefront and aren't afraid of trying new tools, you should give [pixi] a try.\nPixi is a package manager and workflow tool built on the foundation of the conda ecosystem.\nIt provides developers with an easy interface to manage environments and run tasks.\nThe same commands work on all platforms (Linux, macOS and Windows).\n\n`pixi` comes as a single executable.\nRefer to [pixi installation](https://pixi.sh/latest/#installation) for more information.\n\n:::{warning}\nPixi is still in activate development. Ensure you have the latest version available.\n:::\n\nTo compile and install pytango in editable mode, run:\n: - `$ pixi run install`\n\nThis will automatically create a conda environment with all required dependencies.\n\nTo check that pytango was installed properly, you can use `pixi run check`, which is just a shortcut for\n`pixi run python -c 'import tango; print(tango.utils.info())'`. That will print information about the\npytango version installed in the environment.\n\nTo run all the tests:\n: - `$ pixi run test`\n\nYou can run part of the tests by passing any argument to `pytest`:\n: - `$ pixi run pytest -k test_ping`\n\nAll previous commands will run in the `default` environment (with latest python version).\nTo test with a different python version, you can pass another environment to the `pixi run` command.\n\nTo install and test pytango in the `py311` env:\n: - `$ pixi run -e py311 install`\n - `$ pixi run -e py311 pytest`\n\nRun `pixi info` to get a list of all defined environments.\n\n(conda-for-development)=", "text_sha1": "92dc26dcb79de54ee4c965c03854bdd986678439"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Using Conda for development", "level": 2, "chunk_id": "6.0", "text": "## Using Conda for development\n\nIf you don't want to use `pixi`, you can of course create and work in your own [Conda environment](#build-from-source).\n\nTo run the tests locally (after activating your Conda environment):\n: - `$ pytest`\n\nTo run only some tests, use a filter argument, `-k`:\n: - `$ pytest -k test_ping`", "text_sha1": "927f2eff3ccdad69e21ac2dccccb5be964964df8"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Using Docker for development", "level": 2, "chunk_id": "7.0", "text": "## Using Docker for development\n\nDeveloping using a native pixi/conda environment is faster. However, it is also possible to use\nDocker containers for developing, testing and debugging PyTango.\nUse the same manylinux-based image we use for building the Linux binary wheels in CI, for example:\n\\- `docker run --rm -ti registry.gitlab.com/tango-controls/docker/pytango-builder:manylinux2014_x86_64_v2.0.0`\n\nFor direct usage, rather than PyTango development, Docker images with PyTango already\ninstalled are available from the\n[Square Kilometre Array Organisation's repository](https://harbor.skao.int/account/sign-in?globalSearch=ska-tango-images-tango-pytango).\n\nFor example:\n: - `docker run --rm -ti harbor.skao.int/production/ska-tango-images-tango-pytango:9.5.0`", "text_sha1": "2238b3a8d731792dd08d5ccae2210cccbb83aeae"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Releasing a new version", "level": 2, "chunk_id": "8.0", "text": "## Releasing a new version\n\nStarting from 9.4.2 pytango tries to follow cpptango releases with the delay up to ~1 month.\nThe basic steps to make a new release are as follows:\n\nPick a version number\n: - A 3-part version numbering scheme is used: \\<major>.\\<minor>.\\<patch>\n - Note that PyTango **does not** follow [Semantic Versioning](https://semver.org).\n API changes can occur at minor releases (but avoid them if at all possible).\n - The major and minor version fields (e.g., 9.4) track the TANGO C++ core version.\n - Small changes are done as patch releases. For these the version\n number should correspond the current development number since each\n release process finishes with a version bump.\n - Patch release example:\n : - `9.4.4.devN` or `9.4.4rcN` (current development branch)\n - changes to `9.4.4` (the actual release)\n - changes to `9.4.5.dev0` (bump the patch version at the end of the release process)\n - Minor release example:\n : - `9.4.4.devN` or `9.4.4rcN` (current development branch)\n - changes to `9.5.0` (the actual release)\n - changes to `9.5.1.dev0` (bump the patch version at the end of the release process)\n\nCheck which versions of Python should this release support\n: - Follow the [version policy](#pytango-version-policy) and modify correspondingly `requires-python`, `classifiers`,\n and minimum runtime `dependencies` for NumPy in `pyproject.toml`.\n And the `find_package (Python` line in `CMakeLists.txt`.\n\nCreate an issue in GitLab\n: - This is to inform the community that a release is planned.\n\n - Use a checklist similar to the one below:\n\n Task list:\n\n - \\[ \\] Read steps in the how-to-contribute docs for making a release\n\n - \\[ \\] Release candidate testing and fixes complete\n\n - \\[ \\] Merge request to update changelog and bump version\n\n - \\[ \\] Merge MR (this is the last MR for the release)\n\n - \\[ \\] Make sure CI is OK on develop branch\n\n - \\[ \\] Make sure the documentation is updated for develop (readthedocs)\n\n - \\[ \\] Create an annotated tag from develop branch\n\n - \\[ \\] Push stable to head of develop\n\n - \\[ \\] Make sure the documentation is updated for release (readthedocs)\n\n - \\[ \\] Check the new version was automatically uploaded to PyPI\n\n - \\[ \\] Bump the version with \"-dev\" in the develop branch\n\n - \\[ \\] Create and fill in the release description on GitLab\n\n - \\[ \\] Build conda packages\n\n - \\[ \\] Advertise the release on the mailing list\n\n - \\[ \\] Close this issue\n\n - A check list in this form on GitLab can be ticked off as the work progresses.\n\nMake a branch from `develop` to prepare the release\n: - Example branch name: `prepare-v9.4.4`.\n - Edit the changelog (in `docs/revision.rst`). Include *all* merge requests\n since the version was bumped after the previous release. Reverted merge\n requests can be omitted. A command like this could be used to see all the MR numbers, just change the\n initial version:\n `git log --ancestry-path v9.4.3..develop | grep \"merge request\" | sort`\n - Find the versions of the dependencies included in our binary PyPI packages, and update this in `docs/news.md`.\n : - For Linux, see [PyTango CI wheel-linux config](https://gitlab.com/tango-controls/pytango/-/blob/c0812e6b50aca9225939ad6d95bf9546736fac4d/.gitlab-ci.yml#L35),\n and [pytango-builder tags](https://gitlab.com/tango-controls/docker/pytango-builder/-/tags),\n - For Windows: See [cppTango CI config](https://gitlab.com/tango-controls/cppTango/-/blob/9.5.0/.windows-gitlab-ci.yml?ref_type=tags#L17-21),\n [zmq-windows-ci CI config](https://github", "text_sha1": "31bf7387b52937854be28e6d5a1fdff48e12ac8c"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Releasing a new version", "level": 2, "chunk_id": "8.1", "text": ".com/tango-controls/zmq-windows-ci/blob/master/appveyor.yml),\n and [PyTango CI wheel-win config](https://gitlab.com/tango-controls/pytango/-/blob/c0812e6b50aca9225939ad6d95bf9546736fac4d/.gitlab-ci.yml#L72).\n - For macOS: see PyTango CI output, and [cpptango conda-forge feedstock](https://github.com/conda-forge/cpptango-feedstock/)\n CI output (for tango-idl).\n - Bump the versions (`tango/release.py`, `pyproject.toml` and `CMakeLists.txt`).\n E.g. `version_info = (9, 4, 4)`, `version = \"9.4.4\"`, and `VERSION 9.4.4` for a final release. Or, for\n a release candidate: `version_info = (9, 4, 4, \"rc\", 1)`, `version = \"9.4.4.rc1\"`, and `VERSION 9.4.4`.\n - Create a merge request to get these changes reviewed and merged before proceeding.\n\nMake sure CI is OK on `develop` branch\n: - On Gitlab CI all tests, on all versions of Python, must be passing.\n If not, bad luck - you'll have to fix it first, and go back a few steps...\n\nMake sure the documentation is updated\n: - Log in to <https://readthedocs.org>.\n - Get account permissions for <https://readthedocs.org/projects/pytango> from another\n contributor, if necessary.\n - Readthedocs *should* automatically build the docs for each:\n : - push to develop (latest docs)\n - new tags (e.g v9.4.4)\n - *But*, the webhooks are somehow broken, so it probably won't work automatically!\n : - Trigger the builds manually here: <https://readthedocs.org/projects/pytango/builds/>\n - Set the new version to \"active\" here:\n <https://readthedocs.org/dashboard/pytango/versions/>\n\nCreate an annotated tag for the release\n: - GitLab's can be used to create the tag, but a message must be included.\n We don't want lightweight tags.\n - Alternatively, create tag from the command line (e.g., for version 9.4.4):\n : - `$ git checkout develop`\n - `$ git pull`\n - `$ git tag -a -m \"tag v9.4.4\" v9.4.4`\n - `$ git push -v origin refs/tags/v9.4.4`\n\nPush `stable` to head of `develop`\n: - **Skip this step for release candidates!**\n\n - Merge `stable` into the latest `develop`. It is recommended to do a\n fast-forward merge in order to avoid a confusing merge commit. This can be\n done by simply pushing `develop` to `stable` using this command:\n\n > `$ git push origin develop:stable`\n\n This way the release tag corresponds to the actual release commit both on the\n `stable` and `develop` branches.\n\n - In general, the `stable` branch should point to the latest release.\n\nUpload the new version to PyPI\n: - The source tarball and binary wheels are automatically uploaded to PyPI by Gitlab CI on tag.\n\nBump the version with \"-dev\" in the develop branch\n: - Make a branch like `bump-dev-version` from head of `develop`.\n - In `tango/release.py`, change `version_info`, e.g. from `(9, 4, 4)` to\n `(9, 4, 5, \"dev\", 0)`.\n - In `pyproject.toml`, change `version`, e.g. from `\"9.4.4\"` to\n `\"9.4.5.dev0\"`.\n - In `CMakeLists.txt`, change `VERSION`, e.g. from `9.4.4` to\n `9.4.5`.\n - Create MR, merge to `develop`.\n\nCreate and fill in the release description on GitLab\n: - Go to the Tags page: <https://gitlab.com/tango-controls/pytango/-/tags>\n - Find the tag created above and click \"Edit release notes\".\n - Content must be the same as the details in the changelog. List all the\n merge requests since the previous version.\n\nBuild conda packages\n: - Conda-forge is used to build these. See <https://github.com/conda-forge/pytango-feedstock>\n - A new pull request should be created automatically by the Conda forge bot after our tag.\n - Get it merged by one of the maintainers.\n\nAdvert", "text_sha1": "cb0ddea644cef8040f1eca62e2390f5a90d4a42c"}
{"doc_id": "66a6b04dc9c2eee76dcebadacd67b99d0c40f657", "path": "pytango-docsv10.1.12/how-to/how-to-contribute.md", "section": "Releasing a new version", "level": 2, "chunk_id": "8.2", "text": "ise the release on the mailing list\n: - Post on the Python development list.\n - Example of a previous post: <http://www.tango-controls.org/community/forum/c/development/python/pytango-921-release/>\n\nClose off release issue\n: - All the items on the check list should be ticked off by now.\n - Close the issue.\n\n[autodoc]: https://pypi.python.org/pypi/autodoc\n[myst]: https://myst-parser.readthedocs.io/\n[pep8]: https://peps.python.org/pep-0008/\n[pipx]: https://pypa.github.io/pipx/\n[pixi]: https://pixi.sh\n[pre-commit]: https://pre-commit.com\n[restructuredtext]: http://docutils.sourceforge.net/rst.html\n[ruff]: https://github.com/charliermarsh/ruff\n[sphinx]: http://www.sphinx-doc.org/en/stable\n[tutorial]: https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow", "text_sha1": "e9307c2284e8dc692c751f4c99fbe0aced2943dc"}
{"doc_id": "6adf900812f847091f81dd8a84a754280fbe57aa", "path": "pytango-docsv10.1.12/how-to/multiprocessing.md", "section": "Using clients with multiprocessing", "level": 2, "chunk_id": "1.0", "text": "## Using clients with multiprocessing\n\nSince version 9.3.0 PyTango provides {meth}`tango.ApiUtil.cleanup`\nwhich resets CORBA connection.\nThis static function is needed when you want to use {mod}`tango` with\n{mod}`multiprocessing` in your client code.\n\nIn the case when both your parent process and your child process create\n{class}`~tango.DeviceProxy`, {class}`~tango.Database`, {class}`~tango.Group`,\nor/and {class}`~tango.AttributeProxy`\nyour child process inherits the context from your parent process,\ni.e. open file descriptors, the TANGO and the CORBA state.\nSharing the above objects between the processes may cause unpredictable\nerrors, e.g., *TRANSIENT_CallTimedout*, *unidentifiable C++ exception*.\nTherefore, when you start a new process you must reset CORBA connection:\n\n```python\nimport time\nimport tango\n\nfrom multiprocessing import Process\n\nclass Worker(Process):\n\n def run(self):\n # reset CORBA connection\n tango.ApiUtil.cleanup()\n\n proxy = tango.DeviceProxy(\"sys/tg_test/1\")\n\n stime = time.time()\n etime = stime\n while etime - stime < 1.:\n try:\n proxy.read_attribute(\"double_scalar\")\n except Exception as e:\n print(str(e))\n etime = time.time()\n\ndef run_workers():\n workers = [Worker() for _ in range(6)]\n for wk in workers:\n wk.start()\n for wk in workers:\n wk.join()\n\ndb = tango.Database()\ndp = tango.DeviceProxy(\"sys/tg_test/1\")\n\nif __name__ == '__main__':\n for i in range(4):\n run_workers()\n```\n\nAfter `cleanup()` all references to {class}`~tango.DeviceProxy`,\n{class}`~tango.AttributeProxy`, {class}`~tango.Group` or {class}`~tango.Database` objects\nin the current process become invalid\nand these objects need to be reconstructed.", "text_sha1": "65984ee3fa94e5ad310b1fff564e2ae47ccea5be"}
{"doc_id": "6adf900812f847091f81dd8a84a754280fbe57aa", "path": "pytango-docsv10.1.12/how-to/multiprocessing.md", "section": "Multithreading - clients and servers", "level": 2, "chunk_id": "2.0", "text": "## Multithreading - clients and servers\n\nWhen performing Tango I/O from user-created threads, there can be problems.\nThis is often more noticeable with event subscription/unsubscription, and\nwhen pushing events, but it could affect any Tango I/O.\n\nA client subscribing and unsubscribing to events via a user thread may see\na crash, a deadlock, or `Event channel is not responding anymore` errors.\n\nA device server pushing events from a user-created thread (including asyncio\ncallbacks) might see `Not able to acquire serialization (dev, class or process) monitor`\nerrors, if it is using the default [green mode](#green-modes-overview) {obj}`tango.GreenMode.Synchronous`.\n\nIf the device server is using an asynchronous green mode, i.e., {obj}`tango.GreenMode.Gevent` or\n{obj}`tango.GreenMode.Asyncio`, then Tango's [device server serialisation](https://tango-controls.readthedocs.io/en/latest/Explanation/threading.html#serialization-model-within-a-device-server)\nis disabled - see the [green mode warning](#green-modes-no-sync-warning). This means you are\nlikely to see a crash when pushing events from a user thread, especially if an attribute\nis read around the same time. The method described below **WILL NOT** help\nfor this. There is no solution (at least with cppTango 9.5.0 and PyTango 9.5.0, and earlier).\n\nAs PyTango wraps the cppTango library, we need to consider how cppTango's threads work.\ncppTango was originally developed at a time where C++ didn't have standard\nthreads. All the threads currently created in cppTango are \"omni threads\",\nsince this is what the omniORB library is using to create threads and since\nthis implementation is available for free with omniORB.\n\nIn C++, users used to create omni threads in the past so there was no issue.\nSince C++11, C++ comes with an implementation of standard threads.\ncppTango is currently (version 9.4.1) not directly thread safe when\na user is using C++11 standard threads or threads different than omni threads.\nThis lack of thread safety includes threads created from Python's\n{mod}`threading` module.\n\nIn an ideal future cppTango should protect itself, regardless\nof what type of threads are used. In the meantime, we need a work-around.\n\nThe work-around when using threads which are not omni threads is to create an\nobject of the C++ class `omni_thread::ensure_self` in the user thread, just\nafter the thread creation, and to delete this object only when the thread\nhas finished its job. This `omni_thread::ensure_self` object provides a\ndummy omniORB ID for the thread. This ID is used when accessing thread\nlocks within cppTango, so the ID must remain the same for the lifetime\nof the thread. Also note that this object MUST be released before the\nthread has exited, otherwise omniORB will throw an exception.\n\nA Pythonic way to implement this work-around for multithreaded\napplications is available via the {class}`~tango.EnsureOmniThread` class.\nIt was added in PyTango version 9.3.2. This class is best used as a\ncontext handler to wrap the target method of the user thread. An example\nis shown below:\n\n```\nimport tango\nfrom threading import Thread\nfrom time import sleep\n\ndef thread_task():\n with tango.EnsureOmniThread():\n eid = dp.subscribe_event(\n \"double_scalar\", tango.EventType.PERIODIC_EVENT, cb)\n while running:\n print(f\"num events stored {len(cb.get_events())}\")\n sleep(1)\n dp.unsubscribe_event(eid)\n\ncb = tango.utils.EventCallback() # print events to stdout\ndp = tango.DeviceProxy(\"sys/tg_test/1\")\ndp.poll_attribute(", "text_sha1": "026f26fc0edade19efdd37a9a32a0a546953cbeb"}
{"doc_id": "6adf900812f847091f81dd8a84a754280fbe57aa", "path": "pytango-docsv10.1.12/how-to/multiprocessing.md", "section": "Multithreading - clients and servers", "level": 2, "chunk_id": "2.1", "text": "\"double_scalar\", 1000)\nthread = Thread(target=thread_task)\nrunning = True\nthread.start()\nsleep(5)\nrunning = False\nthread.join()\n```\n\nAnother way to create threads in Python is the\n{class}`concurrent.futures.ThreadPoolExecutor`. The problem with this is that\nthe API does not provide an easy way for the context handler to cover the\nlifetime of the threads, which are created as daemons. There are several options here:\n\n1. PyTango has its own {class}`~tango.utils.PyTangoThreadPoolExecutor` (`tango.utils`).\n It is based on the standard {class}`concurrent.futures.ThreadPoolExecutor`\n and does patching with {class}`~tango.EnsureOmniThread` of the each thread at the startup time.\n2. A second option is to at least use the context handler for the functions that are submitted to the\n executor. I.e., `executor.submit(thread_task)`. This is not guaranteed to work.", "text_sha1": "763b024c93f09691005992d89d59513aef694cbd"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "Writing TANGO servers with original API", "level": 1, "chunk_id": "0.0", "text": "# Writing TANGO servers with original API\n\nThis chapter describes how to develop a PyTango device server using the\noriginal PyTango server API. This API mimics the C++ API and is considered\nlow level.\nYou should write a server using this API if you are using code generated by\n[Pogo tool](https://tango-controls.readthedocs.io/en/latest/tools-and-extensions/built-in/pogo/index.html)\nor if for some reason the high level API helper doesn't provide a feature\nyou need (in that case think of writing a mail to tango mailing list explaining\nwhat you cannot do).", "text_sha1": "f15be6fae7c34c76dd10e2b4467ea1f437523d6a"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "The main part of a Python device server", "level": 2, "chunk_id": "1.0", "text": "## The main part of a Python device server\n\nThe rule of this part of a Tango device server is to:\n\n> - Create the {class}`Util` object passing it the Python interpreter command\n> line arguments\n> - Add to this object the list of Tango class(es) which have to be hosted by\n> this interpreter\n> - Initialize the device server\n> - Run the device server loop\n\nThe following is a typical code for this main function:\n\n```{code-block} python\n:linenos: true\nif __name__ == '__main__':\n util = tango.Util(sys.argv)\n util.add_class(PyDsExpClass, PyDsExp)\n\n U = tango.Util.instance()\n U.server_init()\n U.server_run()\n```\n\n**Line 2**\n\n: Create the Util object passing it the interpreter command line arguments\n\n**Line 3**\n\n: Add the Tango class *PyDsExp* to the device server. The {meth}`Util.add_class`\n method of the Util class has two arguments which are the Tango class\n PyDsExpClass instance and the Tango PyDsExp instance.\n This {meth}`Util.add_class` method is only available since version\n 7.1.2. If you are using an older version please use\n {meth}`Util.add_TgClass` instead.\n\n**Line 7**\n\n: Initialize the Tango device server\n\n**Line 8**\n\n: Run the device server loop", "text_sha1": "22c689c53bd69fe18664c4e530ade69bf3ea4d0b"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "The PyDsExpClass class in Python", "level": 2, "chunk_id": "2.0", "text": "## The PyDsExpClass class in Python\n\nThe rule of this class is to :\n\n> - Host and manage data you have only once for the Tango class whatever\n> devices of this class will be created\n> - Define Tango class command(s)\n> - Define Tango class attribute(s)\n\nIn our example, the code of this Python class looks like:\n\n```{code-block} python\n:linenos: true\nclass PyDsExpClass(tango.DeviceClass):\n\n cmd_list = { 'IOLong' : [ [ tango.ArgType.DevLong, \"Number\" ],\n [ tango.ArgType.DevLong, \"Number * 2\" ] ],\n 'IOStringArray' : [ [ tango.ArgType.DevVarStringArray, \"Array of string\" ],\n [ tango.ArgType.DevVarStringArray, \"This reversed array\"] ],\n }\n\n attr_list = { 'Long_attr' : [ [ tango.ArgType.DevLong ,\n tango.AttrDataFormat.SCALAR ,\n tango.AttrWriteType.READ],\n { 'min alarm' : 1000, 'max alarm' : 1500 } ],\n\n 'Short_attr_rw' : [ [ tango.ArgType.DevShort,\n tango.AttrDataFormat.SCALAR,\n tango.AttrWriteType.READ_WRITE ] ]\n }\n```\n\n**Line 1**\n\n: The PyDsExpClass class has to inherit from the {class}`DeviceClass` class\n\n**Line 3 to 7**\n\n: Definition of the cmd_list {class}`dict` defining commands. The *IOLong* command\n is defined at lines 3 and 4. The *IOStringArray* command is defined in\n lines 5 and 6\n\n**Line 9 to 17**\n\n: Definition of the attr_list {class}`dict` defining attributes. The *Long_attr*\n attribute is defined at lines 9 to 12 and the *Short_attr_rw* attribute is\n defined at lines 14 to 16\n\nIf you have something specific to do in the class constructor like\ninitializing some specific data member, you will have to code a class\nconstructor. An example of such a contructor is\n\n```{code-block} python\n:linenos: true\ndef __init__(self, name):\n tango.DeviceClass.__init__(self, name)\n self.set_type(\"TestDevice\")\n```\n\nThe device type is set at line 3.", "text_sha1": "e4051c316430d5e8394931d4bb0f1d00fb474553"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "Defining commands", "level": 2, "chunk_id": "3.0", "text": "## Defining commands\n\nAs shown in the previous example, commands have to be defined in a {class}`dict`\ncalled *cmd_list* as a data member of the xxxClass class of the Tango class.\nThis {class}`dict` has one element per command. The element key is the command\nname. The element value is a python list which defines the command. The generic\nform of a command definition is:\n\n> `'cmd_name' : [ [in_type, <\"In desc\">], [out_type, <\"Out desc\">], <{opt parameters}>]`\n\nThe first element of the value list is itself a list with the command input\ndata type (one of the {class}`tango.ArgType` pseudo enumeration value) and\noptionally a string describing this input argument. The second element of the\nvalue list is also a list with the command output data type (one of the\n{class}`tango.ArgType` pseudo enumeration value) and optionaly a string\ndescribing it. These two elements are mandatory. The third list element is\noptional and allows additional command definition. The authorized element for\nthis {class}`dict` are summarized in the following array:\n\n> | key | Value | Definition |\n> | ----------------- | -------------------- | ---------------------------------------- |\n> | \"display level\" | DispLevel enum value | The command display level |\n> | \"polling period\" | Any number | The command polling period (mS) |\n> | \"default command\" | True or False | To define that it is the default command |", "text_sha1": "1e696c0f0ae864254583d92a0221600204d09c3e"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "Defining attributes", "level": 2, "chunk_id": "4.0", "text": "## Defining attributes\n\nAs shown in the previous example, attributes have to be defined in a {class}`dict`\ncalled **attr_list** as a data\nmember of the xxxClass class of the Tango class. This {class}`dict` has one element\nper attribute. The element key is the attribute name. The element value is a\npython {class}`list` which defines the attribute. The generic form of an\nattribute definition is:\n\n> `'attr_name' : [ [mandatory parameters], <{opt parameters}>]`\n\nFor any kind of attributes, the mandatory parameters are:\n\n> `[attr data type, attr data format, attr data R/W type]`\n\nThe attribute data type is one of the possible value for attributes of the\n{class}`tango.ArgType` pseudo enunmeration. The attribute data format is one\nof the possible value of the {class}`tango.AttrDataFormat` pseudo enumeration\nand the attribute R/W type is one of the possible value of the\n{class}`tango.AttrWriteType` pseudo enumeration. For spectrum attribute,\nyou have to add the maximum X size (a number). For image attribute, you have\nto add the maximun X and Y dimension (two numbers). The authorized elements for\nthe {class}`dict` defining optional parameters are summarized in the following\narray:\n\n> | key | value | definition |\n> | ---------------- | ------------------------------------- | --------------------------------------- |\n> | \"display level\" | tango.DispLevel enum value | The attribute display level |\n> | \"polling period\" | Any number | The attribute polling period (mS) |\n> | \"memorized\" | \"true\" or \"true_without_hard_applied\" | Define if and how the att. is memorized |\n> | \"label\" | A string | The attribute label |\n> | \"description\" | A string | The attribute description |\n> | \"unit\" | A string | The attribute unit |\n> | \"standard unit\" | A number | The attribute standard unit |\n> | \"display unit\" | A string | The attribute display unit |\n> | \"format\" | A string | The attribute display format |\n> | \"max value\" | A number | The attribute max value |\n> | \"min value\" | A number | The attribute min value |\n> | \"max alarm\" | A number | The attribute max alarm |\n> | \"min alarm\" | A number | The attribute min alarm |\n> | \"min warning\" | A number | The attribute min warning |\n> | \"max warning\" | A number | The attribute max warning |\n> | \"delta time\" | A number | The attribute RDS alarm delta time |\n> | \"delta val\" | A number | The attribute RDS alarm delta val |", "text_sha1": "466f3e65f1a59fb4fbd7598cab9d23e2ef3559b1"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "The PyDsExp class in Python", "level": 2, "chunk_id": "5.0", "text": "## The PyDsExp class in Python\n\nThe rule of this class is to implement methods executed by commands and attributes.\nIn our example, the code of this class looks like:\n\n```{code-block} python\n:linenos: true\nclass PyDsExp(tango.Device):\n\n def __init__(self,cl,name):\n tango.Device.__init__(self, cl, name)\n self.info_stream('In PyDsExp.__init__')\n PyDsExp.init_device(self)\n\n def init_device(self):\n self.info_stream('In Python init_device method')\n self.set_state(tango.DevState.ON)\n self.attr_short_rw = 66\n self.attr_long = 1246\n\n #------------------------------------------------------------------\n\n def delete_device(self):\n self.info_stream('PyDsExp.delete_device')\n\n #------------------------------------------------------------------\n # COMMANDS\n #------------------------------------------------------------------\n\n def is_IOLong_allowed(self):\n return self.get_state() == tango.DevState.ON\n\n def IOLong(self, in_data):\n self.info_stream('IOLong', in_data)\n in_data = in_data * 2\n self.info_stream('IOLong returns', in_data)\n return in_data\n\n #------------------------------------------------------------------\n\n def is_IOStringArray_allowed(self):\n return self.get_state() == tango.DevState.ON\n\n def IOStringArray(self, in_data):\n l = range(len(in_data)-1, -1, -1)\n out_index=0\n out_data=[]\n for i in l:\n self.info_stream('IOStringArray <-', in_data[out_index])\n out_data.append(in_data[i])\n self.info_stream('IOStringArray ->',out_data[out_index])\n out_index += 1\n self.y = out_data\n return out_data\n\n #------------------------------------------------------------------\n # ATTRIBUTES\n #------------------------------------------------------------------\n\n def read_attr_hardware(self, data):\n self.info_stream('In read_attr_hardware')\n\n def read_Long_attr(self, the_att):\n self.info_stream(\"read_Long_attr\")\n\n the_att.set_value(self.attr_long)\n\n def is_Long_attr_allowed(self, req_type):\n return self.get_state() in (tango.DevState.ON,)\n\n def read_Short_attr_rw(self, the_att):\n self.info_stream(\"read_Short_attr_rw\")\n\n the_att.set_value(self.attr_short_rw)\n\n def write_Short_attr_rw(self, the_att):\n self.info_stream(\"write_Short_attr_rw\")\n\n self.attr_short_rw = the_att.get_write_value()\n\n def is_Short_attr_rw_allowed(self, req_type):\n return self.get_state() in (tango.DevState.ON,)\n```\n\n**Line 1**\n\n: The PyDsExp class has to inherit from the tango.Device (this will used the latest\n device implementation class available, e.g., Device_6Impl)\n\n**Line 3 to 6**\n\n: PyDsExp class constructor. Note that at line 6, it calls the *init_device()*\n method\n\n**Line 8 to 12**\n\n: The init_device() method. It sets the device state (line 9) and initialises\n some data members\n\n**Line 16 to 17**\n\n: The delete_device() method. This method is not mandatory. You define it\n only if you have to do something specific before the device is destroyed\n\n**Line 23 to 30**\n\n: The two methods for the *IOLong* command. The first method is called\n *is_IOLong_allowed()* and it is the command is_allowed method (line 23 to 24).\n The second method has the same name than the command name. It is the method\n which executes the command. The command input data type is a Tango long\n and therefore, this method receives a python integer.\n\n**Line 34 to 47**\n\n: The two methods for the *IOStringArray* command. The first method is its\n is_allowed method (Line 34 to 35). The second one is the command\n execution method (Line 37 to 47). The command input data type is a string\n array. Therefore, the method receives the", "text_sha1": "c6aa5841bde7ee1e2869f538684e03f602f87fe3"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "The PyDsExp class in Python", "level": 2, "chunk_id": "5.1", "text": "array in a python list of python\n strings.\n\n**Line 53 to 54**\n\n: The *read_attr_hardware()* method. Its argument is a Python sequence of\n Python integer.\n\n**Line 56 to 59**\n\n: The method executed when the *Long_attr* attribute is read. Note that before\n PyTango 7 it sets the attribute value with the tango.set_attribute_value\n function. Now the same can be done using the set_value of the attribute\n object\n\n**Line 61 to 62**\n\n: The is_allowed method for the *Long_attr* attribute. This is an optional\n method that is called when the attribute is read or written. Not defining it\n has the same effect as always returning True. The parameter req_type is of\n type {class}`AttReqtype` which tells if the method is called due to a read\n or write request. Since this is a read-only attribute, the method will only\n be called for read requests, obviously.\n\n**Line 64 to 67**\n\n: The method executed when the *Short_attr_rw* attribute is read.\n\n**Line 69 to 72**\n\n: The method executed when the Short_attr_rw attribute is written.\n Note that before PyTango 7 it gets the attribute value with a call to the\n Attribute method *get_write_value* with a list as argument. Now the write\n value can be obtained as the return value of the *get_write_value* call. And\n in case it is a scalar there is no more the need to extract it from the list.\n\n**Line 74 to 75**\n\n: The is_allowed method for the *Short_attr_rw* attribute. This is an optional\n method that is called when the attribute is read or written. Not defining it\n has the same effect as always returning True. The parameter req_type is of\n type {class}`AttReqtype` which tells if the method is called due to a read\n or write request.", "text_sha1": "260ea2619f610f58b9112a16553818933f4d02ae"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "General methods", "level": 3, "chunk_id": "6.0", "text": "### General methods\n\nThe following array summarizes how the general methods we have in a Tango\ndevice server are implemented in Python.\n\n| Name | Input par (with \"self\") | return value | mandatory |\n| -------------------- | ------------------------ | ------------ | --------- |\n| init_device | None | None | Yes |\n| delete_device | None | None | No |\n| always_executed_hook | None | None | No |\n| signal_handler | {py:obj}`int` | None | No |\n| read_attr_hardware | sequence\\<{py:obj}`int`> | None | No |", "text_sha1": "6146d40ef29ace0e192235b3801e71fc4d0aabcd"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "Implementing a command", "level": 3, "chunk_id": "7.0", "text": "### Implementing a command\n\nCommands are defined as described above. Nevertheless, some methods implementing\nthem have to be written. These methods names are fixed and depend on command\nname. They have to be called:\n\n> - `is_<Cmd_name>_allowed(self)`\n> - `<Cmd_name>(self, arg)`\n\nFor instance, with a command called *MyCmd*, its is_allowed method has to be\ncalled `is_MyCmd_allowed` and its execution method has to be called simply *MyCmd*.\nThe following array gives some more info on these methods.\n\n| Name | Input par (with \"self\") | return value | mandatory |\n| ------------------------ | ----------------------- | ------------------- | --------- |\n| is\\_\\<Cmd_name>\\_allowed | None | Python boolean | No |\n| Cmd_name | Depends on cmd type | Depends on cmd type | Yes |\n\nPlease check {ref}`pytango-data-types` chapter to understand the data types\nthat can be used in command parameters and return values.\n\nThe following code is an example of how you write code executed when a client\ncalls a command named IOLong:\n\n```{code-block} python\n:linenos: true\ndef is_IOLong_allowed(self):\n self.debug_stream(\"in is_IOLong_allowed\")\n return self.get_state() == tango.DevState.ON\n\ndef IOLong(self, in_data):\n self.info_stream('IOLong', in_data)\n in_data = in_data * 2\n self.info_stream('IOLong returns', in_data)\n return in_data\n```\n\n**Line 1-3**\n\n: the is_IOLong_allowed method determines in which conditions the command\n 'IOLong' can be executed. In this case, the command can only be executed if\n the device is in 'ON' state.\n\n**Line 6**\n\n: write a log message to the tango INFO stream (click [here](#logging) for\n more information about PyTango log system).\n\n**Line 7**\n\n: does something with the input parameter\n\n**Line 8**\n\n: write another log message to the tango INFO stream (click [here](#logging) for\n more information about PyTango log system).\n\n**Line 9**\n\n: return the output of executing the tango command", "text_sha1": "ba1606470314f297de511a5a6cd38c23db7be3f6"}
{"doc_id": "1935836691cea0dc96024e4b1ae5f0d087932475", "path": "pytango-docsv10.1.12/how-to/server_old_api.md", "section": "Implementing an attribute", "level": 3, "chunk_id": "8.0", "text": "### Implementing an attribute\n\nAttributes are defined as described in chapter 5.3.2. Nevertheless, some methods\nimplementing them have to be written. These methods names are fixed and depend\non attribute name. They have to be called:\n\n> - `is_<Attr_name>_allowed(self, req_type)`\n> - `read_<Attr_name>(self, attr)`\n> - `write_<Attr_name>(self, attr)`\n\nFor instance, with an attribute called *MyAttr*, its is_allowed method has to be\ncalled *is_MyAttr_allowed*, its read method has to be called *read_MyAttr* and\nits write method has to be called *write_MyAttr*.\nThe *attr* parameter is an instance of {class}`Attr`.\nUnlike the commands, the is_allowed method for attributes receives a parameter\nof type {class}`AttReqtype`.\n\nPlease check {ref}`pytango-data-types` chapter to understand the data types\nthat can be used in attribute.\n\nThe following code is an example of how you write code executed when a client\nread an attribute which is called *Long_attr*:\n\n```{code-block} python\n:linenos: true\ndef read_Long_attr(self, the_att):\n self.info_stream(\"read attribute name Long_attr\")\n the_att.set_value(self.attr_long)\n```\n\n**Line 1**\n\n: Method declaration with \"the_att\" being an instance of the Attribute\n class representing the Long_attr attribute\n\n**Line 2**\n\n: write a log message to the tango INFO stream (click [here](#logging)\n for more information about PyTango log system).\n\n**Line 3**\n\n: Set the attribute value using the method set_value() with the attribute\n value as parameter.\n\nThe following code is an example of how you write code executed when a client\nwrite the Short_attr_rw attribute:\n\n```{code-block} python\n:linenos: true\ndef write_Short_attr_rw(self,the_att):\n self.info_stream(\"In write_Short_attr_rw for attribute \",the_att.get_name())\n self.attr_short_rw = the_att.get_write_value(data)\n```\n\n**Line 1**\n\n: Method declaration with \"the_att\" being an instance of the Attribute\n class representing the Short_attr_rw attribute\n\n**Line 2**\n\n: write a log message to the tango INFO stream (click [here](#logging) for\n more information about PyTango log system).\n\n**Line 3**\n\n: Get the value sent by the client using the method get_write_value() and\n store the value written in the device object. Our attribute is a scalar\n short attribute so the return value is an int", "text_sha1": "57e794305f02f7f4efc55b20d3f68465abf47a35"}
{"doc_id": "6362171549b36a541836844473c12a9b7604fe5b", "path": "pytango-docsv10.1.12/how-to/starting_device.md", "section": "Multiple device classes (Python and C++) in a server", "level": 2, "chunk_id": "1.0", "text": "## Multiple device classes (Python and C++) in a server\n\nWithin the same python interpreter, it is possible to mix several Tango classes.\nLet's say two of your colleagues programmed two separate Tango classes in two\nseparated python files: A {class}`PLC` class in a {file}`PLC.py`:\n\n```", "text_sha1": "27218a3bef2389d9f184ea3fc04e2ca538993ea8"}
{"doc_id": "6362171549b36a541836844473c12a9b7604fe5b", "path": "pytango-docsv10.1.12/how-to/starting_device.md", "section": "PLC.py", "level": 1, "chunk_id": "2.0", "text": "# PLC.py\n\nfrom tango.server import Device\n\nclass PLC(Device):\n\n # bla, bla my PLC code\n\nif __name__ == \"__main__\":\n PLC.run_server()\n```\n\n... and a {class}`IRMirror` in a {file}`IRMirror.py`:\n\n```", "text_sha1": "a6c8635a66a98f2d3f283bd79057aa49233978b9"}
{"doc_id": "6362171549b36a541836844473c12a9b7604fe5b", "path": "pytango-docsv10.1.12/how-to/starting_device.md", "section": "IRMirror.py", "level": 1, "chunk_id": "3.0", "text": "# IRMirror.py\n\nfrom tango.server import Device\n\nclass IRMirror(Device):\n\n # bla, bla my IRMirror code\n\nif __name__ == \"__main__\":\n IRMirror.run_server()\n```\n\nYou want to create a Tango server called `PLCMirror` that is able to contain\ndevices from both PLC and IRMirror classes. All you have to do is write\na {file}`PLCMirror.py` containing the code:\n\n```", "text_sha1": "38bf4989e3c01080e012900a4384c7203e75b024"}
{"doc_id": "6362171549b36a541836844473c12a9b7604fe5b", "path": "pytango-docsv10.1.12/how-to/starting_device.md", "section": "PLCMirror.py", "level": 1, "chunk_id": "4.0", "text": "# PLCMirror.py\n\nfrom tango.server import run\nfrom PLC import PLC\nfrom IRMirror import IRMirror\n\nrun([PLC, IRMirror])\n```\n\nIt is also possible to add C++ Tango class in a Python device server as soon as:\n: 1. The Tango class is in a shared library\n 2. It exist a C function to create the Tango class\n 3. The C++ Tango class is linked against the same `libtango.so` object as PyTango\n (i.e., **cannot be used with binary wheels from PyPI**, but can with conda-forge or a custom build).\n\nFor a Tango class called MyTgClass, the shared library has to be called\nMyTgClass.so and has to be in a directory listed in the LD_LIBRARY_PATH\nenvironment variable. The C function creating the Tango class has to be called\n\\_create_MyTgClass_class() and has to take one parameter of type \"char \\*\" which\nis the Tango class name. Here is an example of the main function of the same\ndevice server than before but with one C++ Tango class called SerialLine:\n\n```\nimport tango\nimport sys\n\nif __name__ == '__main__':\n util = tango.Util(sys.argv)\n util.add_class('SerialLine', 'SerialLine', language=\"c++\")\n util.add_class(PLCClass, PLC, 'PLC')\n util.add_class(IRMirrorClass, IRMirror, 'IRMirror')\n\n U = tango.Util.instance()\n U.server_init()\n U.server_run()\n```\n\n```{eval-rst}\n\n:Line 6: The C++ class is registered in the device server\n:Line 7 and 8: The two Python classes are registered in the device server\n```", "text_sha1": "862eb73bd3e0c367f94c20f6bb3ad37c3b51429e"}
{"doc_id": "6362171549b36a541836844473c12a9b7604fe5b", "path": "pytango-docsv10.1.12/how-to/starting_device.md", "section": "Create/Delete devices dynamically", "level": 2, "chunk_id": "5.0", "text": "## Create/Delete devices dynamically\n\n*This feature is only possible since PyTango 7.1.2*\n\nStarting from PyTango 7.1.2 it is possible to create devices in a device server\n\"en caliente\". This means that you can create a command in your \"management device\"\nof a device server that creates devices of (possibly) several other tango classes.\nThere are two ways to create a new device which are described below.\n\nTango imposes a limitation: the tango class(es) of the device(s) that is(are)\nto be created must have been registered before the server starts.\nIf you use the high level API, the tango class(es) must be listed in the call\nto {func}`~tango.server.run`. If you use the lower level server API, it must\nbe done using individual calls to {meth}`~tango.Util.add_class`.", "text_sha1": "17f51519dd526076b1437e0f5ace05e9a7533bcc"}
{"doc_id": "6362171549b36a541836844473c12a9b7604fe5b", "path": "pytango-docsv10.1.12/how-to/starting_device.md", "section": "Dynamic device from a known tango class name", "level": 3, "chunk_id": "6.0", "text": "### Dynamic device from a known tango class name\n\nIf you know the tango class name but you don't have access to the {class}`tango.DeviceClass`\n(or you are too lazy to search how to get it ;-) the way to do it is call\n{meth}`~tango.Util.create_device` / {meth}`~tango.Util.delete_device`.\nHere is an example of implementing a tango command on one of your devices that\ncreates a device of some arbitrary class (the example assumes the tango commands\n'CreateDevice' and 'DeleteDevice' receive a parameter of type DevVarStringArray\nwith two strings. No error processing was done on the code for simplicity sake):\n\n```\nfrom tango import Util\nfrom tango.server import Device, command\n\nclass MyDevice(Device):\n\n @command(dtype_in=[str])\n def CreateDevice(self, pars):\n klass_name, dev_name = pars\n util = Util.instance()\n util.create_device(klass_name, dev_name, alias=None, cb=None)\n\n @command(dtype_in=[str])\n def DeleteDevice(self, pars):\n klass_name, dev_name = pars\n util = Util.instance()\n util.delete_device(klass_name, dev_name)\n```\n\nAn optional callback can be registered that will be executed after the device is\nregisted in the tango database but before the actual device object is created\nand its init_device method is called. It can be used, for example, to initialize\nsome device properties.", "text_sha1": "52c9d94ab58473de1402062f659c7cb314a2a5f1"}
{"doc_id": "6362171549b36a541836844473c12a9b7604fe5b", "path": "pytango-docsv10.1.12/how-to/starting_device.md", "section": "Dynamic device from a known tango class", "level": 3, "chunk_id": "7.0", "text": "### Dynamic device from a known tango class\n\nIf you already have access to the {class}`~tango.DeviceClass` object that\ncorresponds to the tango class of the device to be created you can call directly\nthe {meth}`~tango.DeviceClass.create_device` / {meth}`~tango.DeviceClass.delete_device`.\nFor example, if you wish to create a clone of your device, you can create a\ntango command called *Clone*:\n\n```\nclass MyDevice(tango.Device):\n\n def fill_new_device_properties(self, dev_name):\n prop_names = db.get_device_property_list(self.get_name(), \"*\")\n prop_values = db.get_device_property(self.get_name(), prop_names.value_string)\n db.put_device_property(dev_name, prop_values)\n\n # do the same for attributes...\n ...\n\n def Clone(self, dev_name):\n klass = self.get_device_class()\n klass.create_device(dev_name, alias=None, cb=self.fill_new_device_properties)\n\n def DeleteSibling(self, dev_name):\n klass = self.get_device_class()\n klass.delete_device(dev_name)\n```\n\nNote that the cb parameter is optional. In the example it is given for\ndemonstration purposes only.", "text_sha1": "de3f1f9c92d8f8d5a108a7e368bf68ee006669d0"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "Background", "level": 2, "chunk_id": "1.0", "text": "## Background\n\nSince version 10.0.0 PyTango provides support for distributed tracing and logging via the [OpenTelemetry](https://opentelemetry.io/docs/what-is-opentelemetry/) framework.\nYou can read all about the concepts on their website.\n\nYou will need a collector to receive the traces and/or logs from your application. This could either be one running\nlocally, or on a remote server. For configuration, the important thing is the collector's endpoint URL and protocol.\n\nE.g., if you run the [Signoz standalone demo](https://signoz.io/docs/install/docker/), there will be a collector\nrunning locally for gRPC and HTTP traffic. Signoz will also provide a website for viewing the telemetry data.\n\nAlternatively, ask your IT infrastructure team if they already have an OpenTelemetry-compatible backend running, what\nthe configuration details are for traces and logs, and how to view the data.\n\n:::{warning}\nEmitting telemetry from a large number of devices servers and clients can generate a high load on\nthe backend receiving this data. There is also small impact on the Tango servers and clients that\nuse this feature. Be careful when enabling this feature, and monitor the performance impact.\nSee the [benchmarks](https://gitlab.com/tango-controls/TangoTickets/-/issues/109).\n:::", "text_sha1": "a7e77fadc9b04c631384bf7c50d80736bc916bf5"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "How to check if your PyTango installation supports telemetry", "level": 2, "chunk_id": "2.0", "text": "## How to check if your PyTango installation supports telemetry\n\nAs a first step, you need at least version 10.0.0, and both PyTango and cppTango must be\ncompiled with telemetry support (i.e., the cppTango CMake compiler option `TANGO_USE_TELEMETRY` was enabled):\n\n```console\n$ python -c \"import tango; print(tango.__version__)\"\n10.0.0\n\n$ python -c \"import tango; print(tango.constants.TELEMETRY_SUPPORTED)\"\nTrue\n```\n\nSee the [PyTango news](#pytango-news) page for which versions of PyTango are packaged\nwith telemetry support compiled in.\n\nThe global enable for OpenTelemetry in Tango is provided by the environment variable `TANGO_TELEMETRY_ENABLE`.\nIt must be set to `on`, to enable telemetry.\n\nNext, you need the OpenTelemetry Python dependencies installed. You can see if these are\ninstalled by simply importing the PyTango library with the environment variable enabled.\n\n```console\n$ TANGO_TELEMETRY_ENABLE=on python -c \"import tango\"\n```\n\nIf there are no warnings, great! Otherwise you may see a warning like:\n\n```console\n$ TANGO_TELEMETRY_ENABLE=on python -c \"import tango\"\n/path/to/python/lib/python3.10/site-packages/tango/utils.py:2427: PyTangoUserWarning:\nOpenTelemetry packages not available:\n...\n```\n\nInstall the packages you need.", "text_sha1": "e1317d1186d4801c704af806f8d5ef9d09a11e3a"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "How to run a device server that emits telemetry", "level": 2, "chunk_id": "3.0", "text": "## How to run a device server that emits telemetry\n\nThere are a number of environment variables related to telemetry. You can read more about them\non this [issue](https://gitlab.com/tango-controls/tango-doc/-/issues/403) (pending a documentation update).\n\nAssuming you have a traces collector using the HTTPS protocol\nlistening at URL `https://traces.my-institute.org:4319/v1/traces`,\nand a logs collector, also using HTTPS, at URL `https://logs.my-institute.org:443/otlp/v1/logs`,\nyou can set your environment up as follows:\n\n```console\n$ export TANGO_TELEMETRY_ENABLE=on\n$ export TANGO_TELEMETRY_TRACES_EXPORTER=http\n$ export TANGO_TELEMETRY_TRACES_ENDPOINT=https://traces.my-institute.org:4319/v1/traces\n$ export TANGO_TELEMETRY_LOGS_EXPORTER=http\n$ export TANGO_TELEMETRY_LOGS_ENDPOINT=https://logs.my-institute.org:443/otlp/v1/logs\n```\n\nAnd then launch your application, as normal.\n\n```console\n$ python MySuperDS.py instance\n```\n\nAnother example is using a local collector, with the gRPC protocol:\n\n```console\n$ export TANGO_TELEMETRY_ENABLE=on\n$ export TANGO_TELEMETRY_TRACES_EXPORTER=grpc\n$ export TANGO_TELEMETRY_TRACES_ENDPOINT=grpc://localhost:4317\n$ export TANGO_TELEMETRY_LOGS_EXPORTER=grpc\n$ export TANGO_TELEMETRY_LOGS_ENDPOINT=grpc://localhost:4317\n```\n\nFor Tango, when using the gRPC protocol, the URLs must start with `grpc://`, even though your backend might\nsuggest an `http://` endpoint for the gRPC traffic.\n\nIf you want to emit traces, but disable logging via the telemetry backend, this can be done by setting\nthe exporter to `none`. This may be useful if your logs are handled by a different system, or your\ntelemetry backend doesn't support logs. This can be done as follows:\n\n```console\n$ export TANGO_TELEMETRY_LOGS_EXPORTER=none\n```\n\n:::{note}\nThe environment variables can be set in a configuration file, similar\nto TANGO_HOST.\nSee the [reference documentation](https://tango-controls.readthedocs.io/en/latest/Reference/reference.html#environment-variables).\n:::", "text_sha1": "346af2e51810aee1a9c178665bea3cdef1315202"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "How to run a client that emits telemetry", "level": 2, "chunk_id": "4.0", "text": "## How to run a client that emits telemetry\n\nThe environment variables mentioned above also apply to clients. Although clients won't emit logs\nto the Tango Logging System. Simply using the client classes, {class}`~tango.DeviceProxy`,\n{class}`~tango.AttributeProxy`, {class}`~tango.Group`, and {class}`~tango.Database`, in such an\nenvironment will emit telemetry.\n\nThe tracer instance ({class}`opentelemetry.trace.Tracer`) used for client requests depends on the context.\nIf it is within a device method for an attribute, command, device initialisation or shutdown, then\nthe device's tracer is used. For all other cases the client tracer (singleton) is used.\n\nBy default, the OpenTelemetry service name associated with client traces from PyTango is\n`pytango.client`. This is very generic, so it is useful to customise this for your own application.\nThis can be done by setting the environment variable `PYTANGO_TELEMETRY_CLIENT_SERVICE_NAME` to\nthe string you prefer. This must be done before the client is used for the first time.\n\nIt could be set programmatically, if the actual environment should be ignored:\n\n```python\nimport os\nimport tango\n\nif __name__ == \"__main__\":\n os.environ[\"PYTANGO_TELEMETRY_CLIENT_SERVICE_NAME\"] = \"my.client\"\n dp = tango.DeviceProxy(\"sys/tg_test/1\")\n dp.ping()\n```", "text_sha1": "74ef6e4c4f31f8a739b18880820e2a972e582df7"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "How to add process information to the telemetry traces", "level": 2, "chunk_id": "5.0", "text": "## How to add process information to the telemetry traces\n\nThe OpenTelemetry Python library has many\n[environmental variables](https://opentelemetry-python.readthedocs.io/en/latest/sdk/environment_variables.html)\nfor configuration.\nOne of them (at least at version 1.25.0) allows additional information about the process to be added\nto each trace. This is done by setting the environment variable `OTEL_EXPERIMENTAL_RESOURCE_DETECTORS=process`.\n\nNote that cppTango uses the C++ OpenTelemetry library, which has different behaviour and configuration.", "text_sha1": "a2124f12186d55d492c740beee246ba9ebc9c465"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "How to add custom information to device traces", "level": 2, "chunk_id": "6.0", "text": "## How to add custom information to device traces\n\nDevices can be customised in two different ways. Firstly, common information can be added\nto all traces. Secondly, specific information can be added in custom spans when performing tasks\nwithin the device.", "text_sha1": "5c8f4c55a1226369b32171c5a142ff42630f56f2"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "Adding common information to all traces", "level": 3, "chunk_id": "7.0", "text": "### Adding common information to all traces\n\nTo add generic resource information, the creation of tracer provider,\n{meth}`~tango.server.Device.create_telemetry_tracer_provider`, can be overridden.\nThis method is called when the device is being initialised, but before `init_device`.\n\n```python\nfrom opentelemetry.trace import TracerProvider\nfrom opentelemetry.sdk.resources import DEPLOYMENT_ENVIRONMENT\nfrom tango.utils import get_telemetry_tracer_provider_factory\n\nclass Example(Device):\n def create_telemetry_tracer_provider(\n self, class_name, device_name\n ) -> TracerProvider:\n tracer_provider_factory = get_telemetry_tracer_provider_factory()\n extra_resource_attributes = {DEPLOYMENT_ENVIRONMENT: \"production\"}\n return tracer_provider_factory(\n class_name, device_name, extra_resource_attributes\n )\n```\n\nEven more customisation is possible by overriding the device's {meth}`~tango.server.Device.create_telemetry_tracer`\nmethod. This method is also called when the device is being initialised, but after the tracer provider has been\ncreated.\n\nFor more extreme cases, the factory used for all device and client tracers can be changed using\n{func}`~tango.utils.set_telemetry_tracer_provider_factory`.", "text_sha1": "b5010a028ee8bce9023256a77a6837a0a17ea642"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "Adding specific information to a span", "level": 3, "chunk_id": "8.0", "text": "### Adding specific information to a span\n\nEach device has its own instance of an {class}`opentelemetry.trace.Tracer`. This tracer associates the\ndevice's spans with the device's name, and its Tango device class. The tracer instance can be\naccessed at runtime using {meth}`~tango.server.Device.get_telemetry_tracer`.\n\nFor example, a partial implementation of a device is shown below with a command handler that creates a custom\nspan. This span automatically inherits the trace context of the caller. When creating the span, it adds\nthe configuration string as an attribute. Note that only a few simple types are allowed as attribute values\n(see {class}`opentelemetry.utils.types.Attributes`). The example also emits an event during the span.\n\n```python\nimport json\nfrom tango.server import Device, command\n\nclass Example(Device):\n\n @command\n def Configure(self, configuration_json: str) -> None:\n device_tracer = self.get_telemetry_tracer()\n with device_tracer.start_as_current_span(\n \"manager.configure\", attributes={\"configuration\": configuration_json}\n ) as span:\n span.add_event(\"configuration requested\")\n configuration = json.loads(configuration_json)\n self._comms_library.configure(configuration)\n```\n\nIt is not necessary to create a new span within a command handler or attribute read/write method, as\nPyTango has already created a span automatically. This span could be accessed as follows:\n\n```python\nimport json\nfrom opentelemetry import trace as trace_api\nfrom tango.server import Device, command\n\nclass Example(Device):\n\n @command\n def Configure(self, configuration_json: str) -> None:\n span = trace_api.get_current_span()\n span.set_attribute(\"configuration\", configuration_json)\n span.add_event(\"configuration requested\")\n configuration = json.loads(configuration_json)\n self._comms_library.configure(configuration)\n```", "text_sha1": "0118f139bf75cd2cf3ab62b2370e8fd35cac6611"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "How to manually instrument your own application", "level": 2, "chunk_id": "9.0", "text": "## How to manually instrument your own application\n\nDevice servers and clients are automatically instrumented, so that they emit spans for\nthe basic operations. However, your custom devices and applications that build on Tango can\nbenefit from additional context. Manual instrumentation is well described in the\n[OpenTelemetry instrumentation docs](https://opentelemetry.io/docs/languages/python/instrumentation/).\n\nYou can create your own custom tracer for your application. It is convenient to use the factory function from\nPyTango, so that you make use of the same environment variables that Tango is using to configure the tracer\nend point.\n\n```python\nfrom opentelemetry import trace as trace_api\nfrom tango.utils import get_telemetry_tracer_provider_factory\n\ntracer_provider_factory = get_telemetry_tracer_provider_factory()\ntracer_provider = tracer_provider_factory(\"my.app\")\ntracer = trace_api.get_tracer(\n instrumenting_module_name=\"my.app.reader\",\n instrumenting_library_version=my_app.__version__,\n tracer_provider=tracer_provider,\n)\n```\n\nThen you can create spans in any interesting functions. Consider a web application\nthat is providing a way to read Tango device attribute values. It may be useful to\nadd details about the requesting client to the span.\n\n```python\nfrom fastapi import FastAPI, Request\n\napp = FastAPI()\n\n@app.get(\"/read_attr_value/{device_name}/{attr_name}\")\ndef read_attr_value(device_name: str, attr_name: str, request: Request):\n with tracer.start_as_current_span(\n \"my-web-proxy.read_attr_value\",\n attributes={\"client.address\": request.client.host}\n ):\n proxy = tango.DeviceProxy(device_name)\n value = proxy.read_attribute(attr_name).value\n return {\"value\": value}\n```\n\n:::{note}\nCreating a span around a very long running task is not recommended. The\nspan is only emitted on completion. Users viewing traces related to such\na span will not get a complete picture until it completes. Also, having\na huge number of child spans (100s to 1000s) will be problematic\nto view in typical web UIs.\n:::\n\nThe Tango logs that go to OpenTelemetry are emitted by cppTango. PyTango doesn't expose\na way to use the logging directly for client-only applications. Devices already have a standard way\nto emit logs. If you want your application's logs to be emitted from Python, this is still an experimental\nfeature in OpenTelemetry Python (as at v1.26.0).\nSee the [logs examples](https://github.com/open-telemetry/opentelemetry-python/tree/v1.26.0/docs/examples/logs).\n\n(telemetry-howto-hide-error-messages)=", "text_sha1": "62ddf272f3f5bb5e412c9fd140ffe7366816640f"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "How to hide error messages when traces cannot be sent", "level": 2, "chunk_id": "10.0", "text": "## How to hide error messages when traces cannot be sent\n\nThe traces are sent to the backend in the background. This might fail if the host is unreachable or too busy.\nIf that happens, the error messages from the OpenTelemtry SDK are printed to stdout. For example:\n\n```\nException while exporting Span batch.\nTraceback (most recent call last):\n ...\n[Error] File: /Users/runner/miniforge3/conda-bld/opentelemetry-sdk_1733208709442/work/exporters/otlp/src/otlp_http_exporter.cc:145 [OTLP TRACE HTTP Exporter] ERROR: Export 6 trace span(s) error: 1\n```\n\nFor an end-user these messages might be confusing, or a nuisance. It is possible to hide them by changing the\nOpenTelemetry SDK's log level. PyTango provides an environment variable, `PYTANGO_TELEMETRY_SDK_LOG_LEVEL`,\nto do this. Set the value to `fatal` before starting your application to hide the error logs.\n\nThe standard Python logging levels are all options: `critical`, `fatal`, `error`, `warning`, `info`, `debug`, `notset`.\n\nThe name of the [opentelemetry-python](https://github.com/open-telemetry/opentelemetry-python) logger used for\nthis may change in future, so there is a second environment variable, `PYTANGO_TELEMETRY_SDK_LOGGER_NAMES`, which\ncan be set to a comma-seperated list of logger names. Defaults are used if the environment variable is empty or\nnot set.\n\n(As at version 1.35.0, opentelemetry-python\n[does not support](https://github.com/open-telemetry/opentelemetry-python/issues/1059) its own `OTEL_LOG_LEVEL`\nenvironment variable).", "text_sha1": "2185b53a0523822952483cc5dda711931bb799a2"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "How to reduce the number of traces being stored", "level": 2, "chunk_id": "11.0", "text": "## How to reduce the number of traces being stored\n\nStoring all traces from all Tango devices in your facility is probably not feasible.\n\nOne option is to only enable telemetry after a problem has occurred, and further\ndebugging is planned. Unfortunately, it means that rare errors typically won't be captured.\nCurrently (as at v10.0.0), the device server or client process has to be restarted with the\ncorrect environment variables to enable telemetry. This is restrictive.\nIn future, there may be a DeviceProxy API to change this at run time, similar to how the\nlogging severity and targets can be changed.\n\nAnother option is to have all devices emitting telemetry, but have the collector apply some filtering\nto reduce the number of traces that get stored.\nThis is the concept of [sampling](https://opentelemetry.io/docs/concepts/sampling/).\nYou may consider a probabilistic sampler, or a [tail sampler](https://opentelemetry.io/blog/2022/tail-sampling/),\nor many of the other contributed samplers.", "text_sha1": "2ffef725b7a1067f077606665a64b358d1eef48b"}
{"doc_id": "74e8c09b51b4d3d0412028ed400985559042f3a7", "path": "pytango-docsv10.1.12/how-to/telemetry.md", "section": "Further examples", "level": 2, "chunk_id": "12.0", "text": "## Further examples\n\nThe\n[prototyping.py](https://gitlab.com/tango-controls/pytango/-/blob/develop/examples/telemetry/prototyping.py)\nfile in the source repository has some further examples, including creating a custom tracer, passing the\ntrace context to a different thread, enabling and disabling telemetry at runtime. Note that while the\ninterface exists for enabling and disabling, it doesn't work correctly in PyTango 10.0.0.", "text_sha1": "13ed0a0571f6b887cc4720b9204f8312fe3cf143"}
{"doc_id": "b546bf474c2872641e91d94f854a907cea8ce9f9", "path": "pytango-docsv10.1.12/how-to/testing/coverage.md", "section": "Test coverage", "level": 2, "chunk_id": "1.0", "text": "## Test coverage\n\nA common tool for measuring code coverage is [Coverage.py](https://coverage.readthedocs.io). From their docs:\n\n> *Coverage.py is a tool for measuring code coverage of Python programs. It monitors your program, noting which parts of the code have been executed, then analyzes the source to identify code that could have been executed but was not.*\n\nThis is a very useful technique improve the quality of source code - both implementation and tests.", "text_sha1": "4cc34087e7c710a29ec6eb35731c733a0569e4f6"}
{"doc_id": "b546bf474c2872641e91d94f854a907cea8ce9f9", "path": "pytango-docsv10.1.12/how-to/testing/coverage.md", "section": "How to run Coverage.py for a PyTango high-level device", "level": 2, "chunk_id": "2.0", "text": "## How to run Coverage.py for a PyTango high-level device\n\nThe recommended approach is to use [pytest](https://pypi.org/project/pytest), with the [pytest-forked](https://pypi.org/project/pytest-forked) and [pytest-cov](https://pypi.org/project/pytest-cov) plugins. See the [issues](#testing-approaches-issues) for notes on why the pytest-forked plugin, or subprocesses in general are necessary. The pytest-cov plugin specifically supports tests run in subprocesses.\n\nFor example:\n\n```\npytest --forked --cov --cov-branch tests/my_tests.py\n```\n\nPrior to pytest-cov 7.0.0, the above method provided higher (more accurate) coverage reporting than using\nCoverage.py directly, like:\n\n```\ncoverage run --branch -m pytest --forked tests/my_tests.py\n```\n\nSince pytest-cov 7.0.0 (which in turn requires Coverage.py >= 7.10.6), the mechanism for handling subprocesses\nchanged. Now, Coverage.py's [run-time patching](https://coverage.readthedocs.io/en/latest/config.html#run-patch)\nhas to be enabled. Add the following patch configuration to your `pyproject.toml` file:\n\n```toml\n[tool.coverage.run]\npatch = [\"subprocess\", \"fork\", \"_exit\"]\n```\n\nThis works well with pytest-cov. However, if you use Coverage.py directly, then there is an extra step of combining\nthe various `.coverage*` files that are created before generating a report.\n\n```shell\ncoverage combine\ncoverage report\n```\n\n:::{note}\nIf checking coverage using the built-in feature of an IDE like PyCharm, it may start tests with `coverage` first, so the same problems with tests in a forked subprocess apply.\nEither enable the run-time patches, or try disabling the forked plugin and running a single test at a time.\n:::", "text_sha1": "f0d6e09a6be67356277d0f62f37877e005894a79"}
{"doc_id": "b546bf474c2872641e91d94f854a907cea8ce9f9", "path": "pytango-docsv10.1.12/how-to/testing/coverage.md", "section": "PyTango run-time patching to support Coverage.py", "level": 2, "chunk_id": "3.0", "text": "## PyTango run-time patching to support Coverage.py\n\n:::{versionadded} 9.4.2\n:::\n\nCoverage.py works (see caveat noted below) by using Python's [sys.settrace](https://docs.python.org/3/library/sys.html#sys.settrace) function to record the execution of every line of code.\nIf you are interested, you can read more about [how it works](https://coverage.readthedocs.io/en/stable/howitworks.html). Unfortunately,\nthis mechanism doesn't automatically work for the callbacks from the cppTango layer. E.g., when a command is executed or an attribute is read, the Python method in your Tango device is generally not called in a thread that Python is aware of. If you were to call `threading.current_thread()` in these callbacks you would see `DummyThread` with a name like `Dummy-2`. The threads are created by cppTango (using omniORB), not with Python's threading module.\n\nIn order to get coverage to work, PyTango does the following:\n\n> 1. Detect if Coverage.py is currently running (when importing `tango/server.py`).\n> 2. If a Coverage.py session is active, and the feature isn't disabled (see environment variable below), then patch all the server methods that would get callbacks from the cppTango layer. This includes `init_device`, `always_executed_hook`, command methods, attribute read/write methods, is allowed methods, etc.\n> 3. The patch calls `sys.setrace(threading._trace_hook)` to install the Coverage.py handler before calling your method. This allows these methods to be analysed for code coverage.\n\nYou can opt out of the patching, by setting the `PYTANGO_DISABLE_COVERAGE_TRACE_PATCHING=1` environment variable. The value it is set to doesn't matter. The presence of the variable disables the patching.\n\n:::{note}\nThis patching is not enabled if Coverage.py is using the \"sysmon\" core\n(using [`sys.monitoring`](https://docs.python.org/3/library/sys.monitoring.html)), a newer feature than `sys.settrace`.\nThis is the default in Coverage.py since 7.9.1, if running on at least Python 3.14.\n:::\n\n:::{note}\nThis patching is only implemented for high-level API devices, in other words, those inheriting from {class}`~tango.server.Device`. Low-level API devices, inheriting from {class}`~tango.device_server.LatestDeviceImpl` (or earlier), do not benefit from this patching.\n:::", "text_sha1": "bfa3da5d867cd3089ca51fd69348f18b1155ed42"}
{"doc_id": "0ce7682332a2911a058c560c5e1bcabc24891c28", "path": "pytango-docsv10.1.12/how-to/testing/mocks.md", "section": "Test Doubles: The idea behind mocking Tango entities", "level": 2, "chunk_id": "1.0", "text": "## Test Doubles: The idea behind mocking Tango entities\n\nSuppose we want to test a Tango Device, **Device A**. In particular, we want to assert that when a certain *action* is invoked on **Device A**, it should produce an expected result. This will prove to us that **Device A** 's implementation sufficiently manifests the behaviour we would like it to have.\n\nNow suppose **Device A** depends on **Device B** to complete its action. In other words, the *result* will depend, in part, on the state of **Device B**. This means that to test this scenario, both devices need to be in a base state that we control.\n\nThis might be difficult to achieve when using real devices since it might require a lot of orchestration and manipulation of details irrelevant to the test scenario, i.e. to get **Device B** into the required state.\n\nA **Test Double** is a component that can act as a real device but is easier to manipulate and configure into the states that we want during testing. This means that we can replace **Device B** with its **Test Double** as long as it conforms to the interface that **Device A** expects.\n\nWhat's more, we can manipulate the **Test Double** to respond in the way we expect **Device B** to respond under the various conditions we want to test. A **Mock** is simply a type of **Test Double** that might have some conditional logic or behaviour to help in testing.\n\n```{image} ../../_static/mocking-tango-test-doubles.png\n```", "text_sha1": "430de203edfb570b222e7b412884bdb4b18067d5"}
{"doc_id": "0ce7682332a2911a058c560c5e1bcabc24891c28", "path": "pytango-docsv10.1.12/how-to/testing/mocks.md", "section": "Tango's DeviceProxys", "level": 2, "chunk_id": "2.0", "text": "## Tango's DeviceProxys\n\nIn Tango, the **DeviceProxy** is an object that allows communication between devices. It can be regarded as the *client* part of a *client-server* interaction.\n\nThus, any Tango device (say, **Device A**) that depends on a secondary Tango device (**Device B**) will need to use a **DeviceProxy** to connect and communicate with the secondary device (**Device B**).\n\nThis invariably means that in the implementation of **Device A**, it will be instantiating and using a **DeviceProxy** object.\n\nHowever, the mechanism by which this happens is a multi-step process which requires communication with a TangoDB DS and an appropriately configured Tango system that contains a deployed **Device B**.\n\n```{image} ../../_static/mocking-tango-db-access.png\n```\n\nIf we can replace the **DeviceProxy** object that **Device A** will use to communicate to **Device B** with our own Mock object (**DeviceProxyMock**), we can test the behaviour of **Device A** while faking the responses it expects to receive from querying **Device B**.\nAll this without the need for deploying a real **Device B**, since for all intents and purposes, the **DeviceProxyMock** would represent the real device.\n\n```{image} ../../_static/mocking-tango-db-access-crossed-out.png\n```\n\nIn other words, mocking the **DeviceProxy** is sufficient to mock the underlying device it connects to, with reference to how **DeviceProxy** is used by **Device A**.", "text_sha1": "17ed44063d50df42fefcf67a1b1596ce0e66bbad"}
{"doc_id": "0ce7682332a2911a058c560c5e1bcabc24891c28", "path": "pytango-docsv10.1.12/how-to/testing/mocks.md", "section": "Mocking the DeviceProxy", "level": 2, "chunk_id": "3.0", "text": "## Mocking the DeviceProxy\n\nIn some **PyTango** devices, such as those in the [SKA TMC Prototype](https://gitlab.com/ska-telescope/tmc-prototype), the **DeviceProxy** object is instantiated during the operation of the **Device Under Test** (**DUT**). Also, there isn't usually an explicit interface to inject a **DeviceProxyMock** as a replacement for the real class.\n\nAs an example, the [CentralNode](https://gitlab.com/ska-telescope/tmc-prototype/-/blob/0.1.8/tmcprototype/CentralNode/CentralNode/CentralNode.py) (at v0.1.8) device from the TMC Prototype instantiates all the **DeviceProxy** objects it needs to connect to its child elements/components in its [init_device](https://gitlab.com/ska-telescope/tmc-prototype/-/blob/0.1.8/tmcprototype/CentralNode/CentralNode/CentralNode.py#L246) method:\n\n```\nclass CentralNode(SKABaseDevice):\n...\n def init_device(self):\n ...\n self._leaf_device_proxy.append(DeviceProxy(self._dish_leaf_node_devices[name]))\n ...\n self._csp_master_leaf_proxy = DeviceProxy(self.CspMasterLeafNodeFQDN)\n ...\n self._sdp_master_leaf_proxy = DeviceProxy(self.SdpMasterLeafNodeFQDN)\n ...\n subarray_proxy = DeviceProxy(self.TMMidSubarrayNodes[subarray])\n```\n\nUnfortunately, the *init_device* method does not allow us to provide the class we want the device to use when it needs to instantiate its **DeviceProxys**.\n\nSo we will have to mock the **DeviceProxy** class that the **DUT** imports before it instantiates that class.\n\nThe diagram below illustrates the relationship between the TestCase, **DUT** and its transitive import of the **DeviceProxy** class from the **PyTango** module:\n\n```{image} ../../_static/mocking-tango-test-case-not-mocked.png\n```\n\nSo, we want to replace the imported **DeviceProxy** class with our own Fake Constructor that will provide a Mocked Device Proxy for the **DUT** during tests.\n\nIn other words, we want to replace the thing that instantiates the **DeviceProxy** (i.e. the constructor) with our own [callable](https://docs.python.org/3.8/reference/expressions.html#calls) object that constructs a mocked **DeviceProxy** object instead of the real one.\nWe want to move from the original implementation to the mocked implementation shown in the diagram below:\n\n```{image} ../../_static/mocking-tango-test-case-real-vs-mocked.png\n```", "text_sha1": "79c7a26388b38707fe4cd1ca065e145f606da2cf"}
{"doc_id": "0ce7682332a2911a058c560c5e1bcabc24891c28", "path": "pytango-docsv10.1.12/how-to/testing/mocks.md", "section": "Solution", "level": 2, "chunk_id": "4.0", "text": "## Solution\n\nThis can be achieved by using the [unittest.mock](https://docs.python.org/3.7/library/unittest.mock.html) library that comes with Python 3.\n\nThe *mock.patch()* method allows us to temporarily change the object that a name points to with another one.\n\nWe use this mechanism to replace the **DeviceProxy** class (constructor) with our own fake constructor (a mock) that returns a Mock object:\n\n```\nwith mock.patch(device_proxy_import_path) as patched_constructor:\n patched_constructor.side_effect = lambda device_fqdn: proxies_to_mock.get(device_fqdn, Mock())\n patched_module = importlib.reload(sys.modules[device_under_test.__module__])\n```\n\nAn alternative to using *mock.patch* is pytest's *monkeypatch*. Its *.setattr* method provides the same functionality, i.e. allowing you to intercept what an object call would normally do and substituting its full execution with your own specification. There are more examples of its use in the OET implementation which is discussed below.\n\n*proxies_to_mock* is a dictionary that maps **DeviceProxyMock** objects to their associated Tango device addresses that we expect the **DUT** to use when instantiating **DeviceProxy** objects. A brand new generic *Mock()* is returned if a specific mapping isn't provided.\n\nSince the **DeviceProxy** class is defined at import time, we will need to reload the module that holds the **DUT**. This is why we explicitly call *importlib.reload(...)* in the context of *mock.patch()*.\n\nFor full details and code that implement this solution, see the following merge requests:\n\n> - <https://gitlab.com/ska-telescope/tmc-prototype/-/merge_requests/23>\n> - <https://gitlab.com/ska-telescope/tmc-prototype/-/merge_requests/35>", "text_sha1": "ab94c11b14f40c48e25b853c683612014a2aa84a"}
{"doc_id": "0ce7682332a2911a058c560c5e1bcabc24891c28", "path": "pytango-docsv10.1.12/how-to/testing/mocks.md", "section": "Moving on", "level": 2, "chunk_id": "5.0", "text": "## Moving on\n\nOnce we mocked **DeviceProxy**, then we can use the constructor of this object to return a device that is fake. This can be:\n\n> - a stub device, programmed to behave in a way that suits the tests that we are writing; in this case we are using the stub to inject other inputs to the **DUT**, under control of the test case;\n> - a mock device, a stub device where we can inspect also how the **DUT** interacted with it, and we can write assertions.\n\nThe benefits that we can achieve with the technique described here are:\n\n> 1. ability to test the **DUT** in isolation\n> 2. ability to create tests that are very fast (no network, no databases)\n> 3. ability to inject into the **DUT** indirect inputs\n> 4. ability to observe the indirect outputs of the **DUT**\n> 5. ability to observe the interactions that the **DUT** has with the mock.", "text_sha1": "4c4bedaf5190b1e34e080ae041be9d50daf879b1"}
{"doc_id": "0ce7682332a2911a058c560c5e1bcabc24891c28", "path": "pytango-docsv10.1.12/how-to/testing/mocks.md", "section": "Using pytest and fixtures", "level": 2, "chunk_id": "6.0", "text": "## Using pytest and fixtures\n\nThe above mocking techniques can be achieved in a very succint way using pytest fixtures.\nExamples of this can be found in the [pytango/examples](https://gitlab.com/tango-controls/pytango/-/tree/develop/examples/multidevicetestcontext). And more examples are\navailable in the last section of the *Unit testing Tango devices in Python* presentation\nfrom the [Tango 2020 November status update meeting](https://indico.esrf.fr/indico/event/49/other-view?view=standard).", "text_sha1": "1c4a2e2b1fdef0b394981e6022f280bf3e300aa4"}
{"doc_id": "97c3cd572743eed1f1abe8282caf2d33f8d600a9", "path": "pytango-docsv10.1.12/how-to/testing/test_context.md", "section": "Device Test Context Classes API", "level": 1, "chunk_id": "0.0", "text": "# Device Test Context Classes API\n\nThe API of the testing classes are described here. For an overview of their behaviour,\nsee {ref}`testing-approaches`.", "text_sha1": "0a9b94f21186eb6730977609aeb5a2141a83e7fc"}
{"doc_id": "97c3cd572743eed1f1abe8282caf2d33f8d600a9", "path": "pytango-docsv10.1.12/how-to/testing/test_context.md", "section": "MultiDeviceTestContext", "level": 2, "chunk_id": "2.0", "text": "## MultiDeviceTestContext\n\n```{eval-rst}\n.. autoclass:: tango.test_context.MultiDeviceTestContext\n :show-inheritance:\n :members:\n :inherited-members:\n```", "text_sha1": "db5cd397fd5cfc7d024e071e582f0e6ebce9831c"}
{"doc_id": "41c486b15825e296ceae05faaf6723d5cdd0f769", "path": "pytango-docsv10.1.12/how-to/testing/testing_approaches.md", "section": "Overview", "level": 2, "chunk_id": "1.0", "text": "## Overview\n\nThe follow sections detail different approaches that can be used when automating tests. This includes starting the real devices as normal in a Tango facility, using the {class}`~tango.test_context.DeviceTestContext` for a more lightweight test, a hybrid approach mixing {class}`~tango.test_context.DeviceTestContext` and real Tango devices in a Tango facility, and starting multiple devices with the {class}`~tango.test_context.DeviceTestContext` and {class}`~tango.test_context.MultiDeviceTestContext`.", "text_sha1": "ba416762ccf2f3c5bf2da766f31a63c8f3b4e05d"}
{"doc_id": "41c486b15825e296ceae05faaf6723d5cdd0f769", "path": "pytango-docsv10.1.12/how-to/testing/testing_approaches.md", "section": "Testing a single device without DeviceTestContext", "level": 3, "chunk_id": "2.0", "text": "### Testing a single device without DeviceTestContext\n\n:::{note}\nThis approach is not recommended for unit testing.\n:::\n\nTesting without a {class}`~tango.test_context.DeviceTestContext` requires a complete Tango environment to be running (this environment is orchestrated by Makefiles and Docker containers in our Tango Example repo). That is, the following four components/processes should be present and configured:\n\n> - DSConfig tool\n> - Tango Databaseds Server\n> - MySQL/MariaDB\n> - Tango Device Server (with Tango device under test inside it)\n\nIn order to successfully constitute a working Tango environment, the following sequence of operations is required:\n\n> 1. A running MySQL/MariaDB service.\n> 2. The Tango Databaseds Server configured to connect to the database.\n> 3. The DSConfig tool can be run to bootstrap the database configuration of the Tango Device based on configuration from a file.\n> 4. The Tango Device Server that has been initialised and running the Tango Device.\n> 5. In the test, you can instantiate a PyTango DeviceProxy object to interact with the Tango device under test.\n\nThis is a lot of infrastructure and complicated to orchestrate - it is not conducive to lightweight, fast running unit tests. Thus it is not recommended.\n\n```{image} ../../_static/testing-approaches-real-facility.png\n```\n\nFigure 1. A schematic diagram showing the agents involved when testing a Tango device using the real Tango database and their interactions.\n\nExamples:\n\n> - [test_2_test_server_using_client.py](https://gitlab.com/ska-telescope/tango-example/-/blob/b20a0b44b4d3499188ffb60e390adab7132fc3a3/post-deployment/tests/test_2_test_server_using_client.py)\n> - [test_3_test_motor_server.py](https://gitlab.com/ska-telescope/tango-example/-/blob/b20a0b44b4d3499188ffb60e390adab7132fc3a3/post-deployment/tests/test_3_test_motor_server.py)\n> - [test_4_test_event_receiver_server.py](https://gitlab.com/ska-telescope/tango-example/-/blob/b20a0b44b4d3499188ffb60e390adab7132fc3a3/post-deployment/tests/test_4_test_event_receiver_server.py)", "text_sha1": "386f001a03c65de4baad8f52fdefa68d191f7606"}
{"doc_id": "41c486b15825e296ceae05faaf6723d5cdd0f769", "path": "pytango-docsv10.1.12/how-to/testing/testing_approaches.md", "section": "Testing a single device with DeviceTestContext", "level": 3, "chunk_id": "3.0", "text": "### Testing a single device with DeviceTestContext\n\nA utility class is provided by PyTango that aids in testing Tango Devices. It automates a lot of the operations required to start up a Tango runtime environment.:\n\n```\nfrom tango.test_context import DeviceTestContext\n```\n\nThe {class}`~tango.test_context.DeviceTestContext` accepts a Tango Device Python class, as an argument, that will be under test (PowerSupply). It also accepts some additional arguments such as properties - see the method signature of {class}`~tango.test_context.DeviceTestContext` constructor.\nIt will then do the following:\nGenerate stubbed data file that has the minimum configuration details for a Tango Device Server to initialise the Tango Device under test (PowerSupply).\nIt will start the Tango Device Server that contains the Tango Device (in a separate thread by default, but optionally in a subprocess).\nDServer is a \"meta\" Tango Device that provides an administrative interface to control all the devices in the Tango Device Server process.\nThe DeviceProxy object can be retrieved from the DeviceContext and can be invoked to interact with Tango Device under test.\nA DeviceProxy object will expose all the attributes and commands specified for the Tango Device as Python objects, but invoking them will communicate with the real device via CORBA. If events are used, these are transported via ZeroMQ.\n\n```{image} ../../_static/testing-approaches-device-test-context.png\n```\n\nFigure 2. A schematic diagram showing the agents involved when testing a Tango device using the {class}`~tango.test_context.DeviceTestContext` and their interactions.\n\nYou may now proceed to exercise the Tango Device's interface by invoking the appropriate methods/properties on the proxy:\n\n```{eval-rst}\n+---------------------------------+-------------------+-------------------------------------------+\n| **Example Code Snippet** | **Tango Concept** | **Description** |\n+---------------------------------+-------------------+-------------------------------------------+\n| ``powersupply_proxy.turn_on()`` | Tango Command | An action that the Tango Device performs. |\n+---------------------------------+-------------------+-------------------------------------------+\n| ``powersupply_proxy.voltage`` | Tango Attribute | A value that the Tango Device exposes. |\n+---------------------------------+-------------------+-------------------------------------------+\n```\n\nExample:\n\n- [test_1_server_in_devicetestcontext.py](https://gitlab.com/ska-telescope/tango-example/-/blob/b20a0b44b4d3499188ffb60e390adab7132fc3a3/post-deployment/tests/test_1_server_in_devicetestcontext.py)", "text_sha1": "1dcf9bd7fdfa1c15a18d750c3c4795fd16762786"}
{"doc_id": "41c486b15825e296ceae05faaf6723d5cdd0f769", "path": "pytango-docsv10.1.12/how-to/testing/testing_approaches.md", "section": "Testing a single device with DeviceTestContext combined with a real device(s) using the Tango database", "level": 3, "chunk_id": "4.0", "text": "### Testing a single device with DeviceTestContext combined with a real device(s) using the Tango database\n\nThis use case first requires the whole test infrastructure described in use case 1 above to be up before the tests can be run against the device (DishLeafNode) in the {class}`~tango.test_context.DeviceTestContext`. The following sequence of events occur to run rests against the device (DishLeafNode):\n\n> - Set up the test infrastructure for the real device - DishMaster (all the steps defined for use case 1 above apply).\n>\n> - Set up the test infrastructure for the device (DishLeafNode) in the {class}`~tango.test_context.DeviceTestContext` (all steps in use case 2 above apply).\n>\n> - Create a proxy (dish_proxy) which exposes the attributes and commands of the real device to be tested.\n>\n> - There's a [proxy](https://gitlab.com/ska-telescope/tmc-prototype/-/blob/379257d60186814ec3746a7567d4fd90594bfca3/tmcprototype/DishLeafNode/DishLeafNode/DishLeafNode.py#L437) in the provisioned {class}`~tango.test_context.DeviceTestContext` which knows about the real device but cannot expose its attributes and commands in that context, hence the need for the dish_proxy.\n\n```{image} ../../_static/testing-approaches-hybrid.png\n```\n\nFigure 3. A schematic diagram showing the agents involved when testing multiple Tango devices using the {class}`~tango.test_context.DeviceTestContext` together with the real Tango database and their interactions.\n\nExamples:\n\n> - [DishLeafNode/conftest.py](https://gitlab.com/ska-telescope/tmc-prototype/-/blob/379257d60186814ec3746a7567d4fd90594bfca3/tmcprototype/DishLeafNode/conftest.py#L79)", "text_sha1": "be7974d4c048fbfe414fa7e60ee7f25ea4f5393e"}
{"doc_id": "41c486b15825e296ceae05faaf6723d5cdd0f769", "path": "pytango-docsv10.1.12/how-to/testing/testing_approaches.md", "section": "Testing with multiple DeviceTestContexts", "level": 3, "chunk_id": "5.0", "text": "### Testing with multiple DeviceTestContexts\n\n:::{warning}\nThis approach is not recommended - rather use {class}`~tango.test_context.MultiDeviceTestContext`.\n:::\n\nThe testing scenario depicted in Figure 3 can be implemented without using the real Tango database. In this use case, the underlying device (DishMaster) is provisioned using the {class}`~tango.test_context.DeviceTestContext`. Just like in the use case above, another proxy (dish_proxy) is created to expose the commands and attributes of the DishMaster Device. The sequence of events which take place to provision each of these DeviceTestContexts are exactly the same as described in use case 1. This is not recommended because it can be done more easily using the {class}`~tango.test_context.MultiDeviceTestContext`, as shown in the next section.\n\nFrom PyTango 9.5.0, this will require setting `process=True` on the nested {class}`~tango.test_context.DeviceTestContext` instances.\n\n```{image} ../../_static/testing-approaches-device-test-context-x2.png\n```\n\nFigure 4. A schematic diagram showing the agents involved when testing multiple Tango devices using the {class}`~tango.test_context.DeviceTestContext` and their interactions.\n\nExamples:\n\n> - [Tango forum post](https://www.tango-controls.org/community/forum/post/3807/)", "text_sha1": "426ae931bae27ebae579c0fbc733557a8a6b6a38"}
{"doc_id": "41c486b15825e296ceae05faaf6723d5cdd0f769", "path": "pytango-docsv10.1.12/how-to/testing/testing_approaches.md", "section": "Testing with MultiDeviceTestContext", "level": 3, "chunk_id": "6.0", "text": "### Testing with MultiDeviceTestContext\n\nThere is another testing class available in PyTango: {class}`~tango.test_context.MultiDeviceTestContext`, which helps to simplify testing of multiple devices. In this case the multiple devices are all launched in a single device server.:\n\n```\nfrom tango.test_context import MultiDeviceTestContext\n```\n\nThe testing scenario depicted in Figure 4 can be implemented with just a single {class}`~tango.test_context.MultiDeviceTestContext` instead of two {class}`~tango.test_context.DeviceTestContext` instances (and still without using the real Tango database). In this use case, both devices (DishMaster and DishLeafNode) are provisioned using the {class}`~tango.test_context.MultiDeviceTestContext`. Just like in the use case above, another proxy (dish_proxy) is created to expose the commands and attributes of the DishMaster Device to the test runner. The sequence of events which take place to provision this MultiDeviceTestContexts is similar that use case 1. The main difference is the devices_info the must be specified beforehand. Here we can define the devices that must be started, their names, and initial properties.\n\n```{image} ../../_static/testing-approaches-multi-device-test-context.png\n```\n\nFigure 5. A schematic diagram showing the agents involved when testing multiple Tango devices using the {class}`~tango.test_context.MultiDeviceTestContext` and their interactions.\n\nExamples:\n\n- [MultiDeviceTestContext with fixtures](https://gitlab.com/tango-controls/pytango/-/tree/develop/examples/multidevicetestcontext)\n\n(testing-approaches-issues)=", "text_sha1": "31515aef69614ed2acaa1e6073eafa2977da6ab9"}
{"doc_id": "41c486b15825e296ceae05faaf6723d5cdd0f769", "path": "pytango-docsv10.1.12/how-to/testing/testing_approaches.md", "section": "Issues", "level": 2, "chunk_id": "7.0", "text": "## Issues\n\n> 1. A single process that attempts to use a {class}`~tango.test_context.DeviceTestContext` multiple times in threaded mode (so kwarg `process=False`, or unspecified), will get a segmentation fault on the second usage. The segfault can be avoided using the [pytest-forked](https://pypi.org/project/pytest-forked) plugin to run tests in separate processes (Linux and macOS, but not Windows). Either mark individual tests with the `@pytest.mark.forked` decorator, or use the `pytest --forked` command line option to run every test in a new process. Running each test in a new process slows things down, so consider if all tests or just some tests need this.\n> 2. Another way to avoid the segfault with multiple uses of {class}`~tango.test_context.DeviceTestContext` is by setting the kwarg `process=True`. In this case we don't need the forked execution, but consider the disadvantages in the previous section.\n> 3. Forwarded attributes do not work.\n> 4. There is no way to unit test (in the strict definition), since the Tango device objects cannot be directly instantiated.\n> 5. The {class}`~tango.test_context.DeviceTestContext` is quite a heavyweight utility class in terms of the dependent components it needs to orchestrate so that testing can be done. It requires the Tango runtime, including ZeroMQ for events, and a Database stub file as a minimum.\n\n:::{note}\nThe same issues apply to {class}`~tango.test_context.MultiDeviceTestContext`.\n:::\n\n(testing-approaches-process-kwarg)=", "text_sha1": "b9dc4392b407fff33494fd967ff94374e00c1758"}
{"doc_id": "41c486b15825e296ceae05faaf6723d5cdd0f769", "path": "pytango-docsv10.1.12/how-to/testing/testing_approaches.md", "section": "The `process` kwarg: thread vs. subprocess modes", "level": 2, "chunk_id": "8.0", "text": "## The `process` kwarg: thread vs. subprocess modes\n\nWhen using {class}`~tango.test_context.DeviceTestContext` or ({class}`~tango.test_context.MultiDeviceTestContext`) with the kwarg `process=False` (default), the Tango Device server runs in the same operating system process as the code that starts the {class}`~tango.test_context.DeviceTestContext` (normally the test runner). With `process=True`, a new subprocess is created and the device server runs in that subprocess. In other words, a different operating system process to the test runner. In both cases, the test runner can communicate with the device is via a client like {class}`~tango.DeviceProxy` or {class}`~tango.AttributeProxy`.\n\nThere is a subtle detail to note when using the `process=True` option with a nested device class. Consider the following example:\n\n```\nfrom tango import DevState\nfrom tango.server import Device\nfrom tango.test_context import DeviceTestContext\n\ndef test_empty_device_in_state_unknown():\n class TestDevice(Device):\n pass\n\n with DeviceTestContext(TestDevice, process=False) as proxy:\n assert proxy.state() == DevState.UNKNOWN\n```\n\nThis will work fine, using thread-based mode. However, if we use the subproces mode, i.e., `process=True`, we will get an error about serialisation of the class using pickle, like: `AttributeError: Can't pickle local object 'test_empty_device_in_state_unknown.<locals>.TestDevice'`. It fails when Python creates a subprocess using multiprocessing - the nested class definition cannot be passed to the subprocess.\n\nOne solution is to move the test class out of the function:\n\n```\nfrom tango import DevState\nfrom tango.server import Device\nfrom tango.test_context import DeviceTestContext\n\nclass TestEmptyDevice(Device):\n pass\n\ndef test_empty_device_in_state_unknown():\n with DeviceTestContext(TestEmptyDevice, process=True) as proxy:\n assert proxy.state() == DevState.UNKNOWN\n```\n\nThe next detail to consider is that the memory address space for two processes is independent. If we use `process=False` the device under test is running in the same process as the test runner, so we can access variables inside the class being tested (or even the device instance, if we keep a reference to it). With `process=True` the test runner cannot access the device server's memory.\n\nExample of accessing class variables and device internals (only possible with `process=False`):\n\n```\nfrom weakref import WeakValueDictionary\n\nfrom tango.server import Device\nfrom tango.test_context import DeviceTestContext\n\nclass TestDeviceInternals(Device):\n class_variable = 0\n instances = WeakValueDictionary()\n\n def init_device(self):\n super().init_device()\n TestDeviceInternals.class_variable = 123\n TestDeviceInternals.instances[self.get_name()] = self\n self._instance_variable = 456\n\ndef test_class_and_device_internals_accessible_with_process_false():\n with DeviceTestContext(TestDeviceInternals, process=True) as proxy:\n assert TestDeviceInternals.class_variable == 123\n\n device_instance = TestDeviceInternals.instances[proxy.dev_name()]\n assert device_instance._instance_variable == 456\n```\n\nThe `weakref.WeakValueDictionary` isn't critical to this test (it could have been a standard dict), but it is shown as a way to avoid reference cycles in the `instances` dict. For example, if a device server were creating and deleting device instances at runtime. The reference cycles would prevent the cleanup of device instances by Python's garbage collector.", "text_sha1": "635137005d543937febaf56269af6e9a52b93d12"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "Python clients to TANGO servers", "level": 1, "chunk_id": "0.0", "text": "# Python clients to TANGO servers\n\nIn the examples here we connect to a device called *sys/tg_test/1* that runs in a\nTANGO server called *TangoTest* with the instance name *test*.\nThis server comes with the TANGO installation. The TANGO installation\nalso registers the *test* instance. All you have to do is start the TangoTest\nserver on a console:\n\n```\n$ TangoTest test\nReady to accept request\n```\n\n:::{note}\nif you receive a message saying that the server is already running,\nit just means that somebody has already started the test server so you don't\nneed to do anything.\n:::\n\n:::{note}\nPyTango used to come with an integrated [IPython](https://ipython.org) based console called\n{ref}`itango`, now moved to a separate project. It provides helpers to simplify\nconsole usage. You can use this console instead of the traditional python\nconsole. Be aware, though, that many of the *tricks* you can do in an\n{ref}`itango` console cannot be done in a python program.\n:::", "text_sha1": "55749d92bec8f67e8cafac9a5a3ab2a0ccfc6cdd"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "Test the connection to the Device and get it's current state", "level": 2, "chunk_id": "1.0", "text": "## Test the connection to the Device and get it's current state\n\nOne of the most basic examples is to get a reference to a device and\ndetermine if it is running or not:\n\n```\nimport tango", "text_sha1": "fc0cb1af08d6b3e559e339eeb0a826aac93a1809"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "every device has a state and status which can be checked with:", "level": 1, "chunk_id": "4.0", "text": "# every device has a state and status which can be checked with:\nprint(f\"State: {tango_test.state()}\")\nprint(f\"Status: {tango_test.status()}\")\n```\n\nIf you execute:\n\n```\nPing: 264\nState: RUNNING\nStatus: The device is in RUNNING state.\n```", "text_sha1": "259e05a53f3ccf653ba38d10873c0cebe06fb7af"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "Write a scalar attribute", "level": 1, "chunk_id": "10.0", "text": "# Write a scalar attribute\nscalar_value = 18\ntango_test.write_attribute(\"long_scalar\", scalar_value)\n```\n\nIf you execute:\n\n```\nCreating proxy to TangoTest device...\nLong_scalar value = 44\n\nDeviceAttribute[\ndata_format = tango._tango.AttrDataFormat.SCALAR\n dim_x = 1\n dim_y = 0\n has_failed = False\n is_empty = False\n name = 'long_scalar'\n nb_read = 1\n nb_written = 1\n quality = tango._tango.AttrQuality.ATTR_VALID\nr_dimension = AttributeDimension(dim_x = 1, dim_y = 0)\n time = TimeVal(tv_nsec = 0, tv_sec = 1707833196, tv_usec = 456892)\n type = tango._tango.CmdArgType.DevLong\n value = 44\n w_dim_x = 1\n w_dim_y = 0\nw_dimension = AttributeDimension(dim_x = 1, dim_y = 0)\nw_value = 0]\n```\n\nPyTango also provides more \"pythonic\" way - so called High API, to do the same:\n\n```\nfrom tango import DeviceProxy", "text_sha1": "ad508cccc4f68cdf9e607cb4bdf61cf3e97ba97a"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "Check the complete DeviceAttribute members:", "level": 1, "chunk_id": "14.0", "text": "# Check the complete DeviceAttribute members:\nscalar_value = tango_test[\"long_scalar\"]\nprint(f\"\\nLong_scalar attribute:\\n{scalar_value}\")\n```\n\nif you run:\n\n```\nCreating proxy to TangoTest device...\nLong_scalar value = 8\n\nLong_scalar attribute:\nDeviceAttribute[\ndata_format = tango._tango.AttrDataFormat.SCALAR\n dim_x = 1\n dim_y = 0\n has_failed = False\n is_empty = False\n name = 'long_scalar'\n nb_read = 1\n nb_written = 1\n quality = tango._tango.AttrQuality.ATTR_VALID\nr_dimension = AttributeDimension(dim_x = 1, dim_y = 0)\n time = TimeVal(tv_nsec = 0, tv_sec = 1707833578, tv_usec = 542918)\n type = tango._tango.CmdArgType.DevLong\n value = 8\n w_dim_x = 1\n w_dim_y = 0\nw_dimension = AttributeDimension(dim_x = 1, dim_y = 0)\n w_value = 8]\n```\n\nThe multidimensional attributes in Pytango by defaults are numpy arrays (SPECTRUM - 1D, IMAGE - 2D).\nThis results in a faster and more memory efficient PyTango:\n\n```\nfrom tango import DeviceProxy\ntango_test = DeviceProxy(\"sys/tg_test/1\")\n\nprint(f\"double_spectrum: {tango_test.double_spectrum}\")\nprint(f\"double_spectrum type: {type(tango_test.double_spectrum)}\")\n```\n\nResult:\n\n```\ndouble_spectrum: [0. 0. 0. ..... 0. 0.]\ndouble_spectrum type: <class 'numpy.ndarray'>\n```\n\nYou can also use numpy to specify the values when\nwriting attributes, especially if you know the exact attribute type:\n\n```\nfrom tango import DeviceProxy\nimport numpy\n\ntango_test = DeviceProxy(\"sys/tg_test/1\")\n\ntango_test.long_spectrum = numpy.arange(0, 100, dtype=numpy.int32)\n\ndata_2d_float = numpy.zeros((10, 20), dtype=numpy.float64)\ntango_test.double_image = data_2d_float\n```\n\nHowever, if you want, you can force python's types:\n\n```\nfrom tango import DeviceProxy, ExtractAs\ntango_test = DeviceProxy(\"sys/tg_test/1\")\n\ndouble_spectrum = tango_test.read_attribute(\"double_spectrum\", extract_as=ExtractAs.List)\n\nprint(f\"double_spectrum: {double_spectrum.value}\")\nprint(f\"double_spectrum type: {type(double_spectrum.value)}\")\n```\n\nResult:\n\n```\ndouble_spectrum: [0.0, 0.0, 0.0, .... 0.0, 0.0]\ndouble_spectrum type: <class 'list'>\n```", "text_sha1": "3f978b9916ce95907abd6384938e98f71bec2812"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "DeviceProxy's and AttributeProxy's hasattr method peculiarities:", "level": 2, "chunk_id": "15.0", "text": "## DeviceProxy's and AttributeProxy's hasattr method peculiarities:\n\nThe `hasattr` method of DeviceProxy and inheriting AttributeProxy classes could sometime raise an exception.\nPython's `hasattr` uses `getattr()`, so it calls the DeviceProxy's custom `__getattr__` method. This is going to try and read the attribute from the remote Tango device. You will get an exception if the device is not reachable, times out, or raises an exception when read. E.g., an attribute with an \"is allowed\" check, could raise because it may not be read at the moment.\n\nSo this method is not a reliable way to check if a device has a certain Tango attribute. There are a few alternative options:", "text_sha1": "66cf4236fd2e262722f63cd9b759d539a428e4eb"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "2. Use Python's `dir()` built-in", "level": 3, "chunk_id": "17.0", "text": "### 2. Use Python's `dir()` built-in\n\nThis calls the custom `DeviceProxy.__dir__` method.\n\n```py\npython_or_tango_attr_exists = \"your_attribute\" in dir(your_device_proxy)\n```\n\nNote:\n- Doesn't raise, even if device is not available\n- Checks both commands and attributes, with a fresh call to `get_command_list()` and ` get_attribute_list()`.\n- Also includes all methods on the DeviceProxy object, like `ping`, `name`, `subscribe_event`, etc.\n- The `dir()` result includes the Tango attribute and commands in both original, and lower case. If you have an attribute called `myAttr` or `myATTR`, you could always check for `\"myattr\" in dir(det8.proxy)`.", "text_sha1": "9caf83e7cedfd4c6bbe6d33d5f7e8049384e110f"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "3. Use the `in` keyword", "level": 3, "chunk_id": "18.0", "text": "### 3. Use the `in` keyword\n\nThis calls the custom `DeviceProxy.__contains__` method.\n\n```py\ntango_attr_exists = \"your_attribute\" in your_device_proxy\n```\n\nNote:\n - Only check attributes, doing a fresh `get_attribute_list()`.\n - Does a case-insensitive check. Something like `\"YoUr_AttRiBuTe\" in your_device_proxy` would also work.\n - Raises a `DevFailed` exception if the `get_attribute_list()` call fails.", "text_sha1": "abb7a2a6ea2433c69457910a5809efe78fb6d265"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "Execute commands", "level": 2, "chunk_id": "19.0", "text": "## Execute commands\n\nAs you can see in the following example, when scalar types are used, the Tango\nbinding automagically manages the data types, and writing scripts is quite easy:\n\n```\nfrom tango import DeviceProxy\ntango_test = DeviceProxy(\"sys/tg_test/1\")", "text_sha1": "5d1b1a6493e626b38ece041c2145504a7e908702"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "(DevString in this case is a command of the Tango_Test device)", "level": 1, "chunk_id": "21.0", "text": "# (DevString in this case is a command of the Tango_Test device)\n\nresult = tango_test.command_inout(\"DevString\", \"First hello to device\")\nprint(f\"Result of execution of DevString command = {result}\")", "text_sha1": "a59bf842ee2c834747f700bc5e3e845f6c7ef003"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "the same can be achieved with a helper method", "level": 1, "chunk_id": "22.0", "text": "# the same can be achieved with a helper method\nresult = tango_test.DevString(\"Second Hello to device\")\nprint(f\"Result of execution of DevString command = {result}\")", "text_sha1": "ccd4be1a069cd4bf4ade0256276b637a35b2fcee"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "Please note that argin argument type is automatically managed by python", "level": 1, "chunk_id": "23.0", "text": "# Please note that argin argument type is automatically managed by python\nresult = tango_test.DevULong(12456)\nprint(f\"Result of execution of DevULong command = {result}\")\n```\n\nResult:\n\n```\nResult of execution of DevString command = First hello to device\nResult of execution of DevString command = Second Hello to device\nResult of execution of DevULong command = 12456\n```", "text_sha1": "9358294dca0545ad4a52d38209ac80d7200c1ba6"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "Execute commands with more complex types", "level": 2, "chunk_id": "24.0", "text": "## Execute commands with more complex types\n\nIn this case you have to use put your arguments data in the correct python\nstructures:\n\n```\nfrom tango import DeviceProxy\ntango_test = DeviceProxy(\"sys/tg_test/1\")", "text_sha1": "cbf1bf99dc6e9faeeed1f75174a11a847be1f519"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "variable containing an array of longs and an array of strings", "level": 1, "chunk_id": "26.0", "text": "# variable containing an array of longs and an array of strings\nargin = ([1,2,3], [\"Hello\", \"TangoTest device\"])\nresult = tango_test.DevVarLongStringArray(argin)\nprint(f\"Result of execution of DevVarLongArray command = {result}\")\n```\n\nResult:\n\n```\nResult of execution of DevVarLongArray command = [array([1, 2, 3], dtype=int32), ['Hello', 'TangoTest device']]\n```", "text_sha1": "9208731bfda17294d87aa71edd551e74673e8251"}
{"doc_id": "ce088ca3e984bd41fc78722bbf064eec15d370a2", "path": "pytango-docsv10.1.12/tutorial/clients.md", "section": "Handle errors", "level": 2, "chunk_id": "28.0", "text": "## Handle errors\n\n```{eval-rst}\n.. todo::\n write this how to\n```\n\nThis is just the tip of the iceberg. Check the {class}`~tango.DeviceProxy` for\nthe complete API.", "text_sha1": "a2a6c297d844e4e087ccb4b7d8679cfdb58296c5"}
{"doc_id": "d9438e883d55357b2e41c9877d646c8a65fc3782", "path": "pytango-docsv10.1.12/tutorial/database.md", "section": "Note: these 3 devices will be served by the same DServer", "level": 1, "chunk_id": "4.0", "text": "# Note: these 3 devices will be served by the same DServer\nnew_device_name1 = \"px1/tdl/mouse1\"\nnew_device_name2 = \"px1/tdl/mouse2\"\nnew_device_name3 = \"px1/tdl/mouse3\"", "text_sha1": "9d4d4588d5a889491d20a3139ef5a783ba70d2c9"}
{"doc_id": "d9438e883d55357b2e41c9877d646c8a65fc3782", "path": "pytango-docsv10.1.12/tutorial/database.md", "section": "Define the Tango Class served by this DServer", "level": 1, "chunk_id": "5.0", "text": "# Define the Tango Class served by this DServer\nnew_device_info_mouse = DbDevInfo()\nnew_device_info_mouse._class = \"Mouse\"\nnew_device_info_mouse.server = \"ds_Mouse/server_mouse\"", "text_sha1": "a0bea410fc4b3106685ea461bba046c0b65a9d42"}
{"doc_id": "d9438e883d55357b2e41c9877d646c8a65fc3782", "path": "pytango-docsv10.1.12/tutorial/database.md", "section": "add the first device", "level": 1, "chunk_id": "6.0", "text": "# add the first device\nprint(\"Creating device: %s\" % new_device_name1)\nnew_device_info_mouse.name = new_device_name1\ndb.add_device(new_device_info_mouse)", "text_sha1": "d5f8fccad6b7942a1c6cfe60e1f9192ca6d52150"}
{"doc_id": "d9438e883d55357b2e41c9877d646c8a65fc3782", "path": "pytango-docsv10.1.12/tutorial/database.md", "section": "add the next device", "level": 1, "chunk_id": "7.0", "text": "# add the next device\nprint(\"Creating device: %s\" % new_device_name2)\nnew_device_info_mouse.name = new_device_name2\ndb.add_device(new_device_info_mouse)", "text_sha1": "9011922cb850688642e0f000810bd171c2f7a7d8"}
{"doc_id": "d9438e883d55357b2e41c9877d646c8a65fc3782", "path": "pytango-docsv10.1.12/tutorial/database.md", "section": "add the third device", "level": 1, "chunk_id": "8.0", "text": "# add the third device\nprint(\"Creating device: %s\" % new_device_name3)\nnew_device_info_mouse.name = new_device_name3\ndb.add_device(new_device_info_mouse)\n```", "text_sha1": "5c1f96a0c6460701d6ddd1888334fe92839c9163"}
{"doc_id": "d9438e883d55357b2e41c9877d646c8a65fc3782", "path": "pytango-docsv10.1.12/tutorial/database.md", "section": "Setting up device properties", "level": 3, "chunk_id": "9.0", "text": "### Setting up device properties\n\nA more complex example using python subtilities.\nThe following python script example (containing some functions and instructions\nmanipulating a Galil motor axis device server) gives an idea of how the Tango\nAPI should be accessed from Python:\n\n```\nfrom tango import DeviceProxy", "text_sha1": "d98caabda6c29527e7f0003392bb175d8a56016f"}
{"doc_id": "d9438e883d55357b2e41c9877d646c8a65fc3782", "path": "pytango-docsv10.1.12/tutorial/database.md", "section": "Getting Device Properties", "level": 1, "chunk_id": "11.0", "text": "# Getting Device Properties\nproperty_names = [\"AxisBoxAttachement\",\n \"AxisEncoderType\",\n \"AxisNumber\",\n \"CurrentAcceleration\",\n \"CurrentAccuracy\",\n \"CurrentBacklash\",\n \"CurrentDeceleration\",\n \"CurrentDirection\",\n \"CurrentMotionAccuracy\",\n \"CurrentOvershoot\",\n \"CurrentRetry\",\n \"CurrentScale\",\n \"CurrentSpeed\",\n \"CurrentVelocity\",\n \"EncoderMotorRatio\",\n \"logging_level\",\n \"logging_target\",\n \"UserEncoderRatio\",\n \"UserOffset\"]\n\naxis_properties = axis1.get_property(property_names)\nfor prop in axis_properties.keys():\n print(\"%s: %s\" % (prop, axis_properties[prop][0]))", "text_sha1": "e7668115d50730c5a36fcf06e3424f89466a4261"}
{"doc_id": "d9438e883d55357b2e41c9877d646c8a65fc3782", "path": "pytango-docsv10.1.12/tutorial/database.md", "section": "Changing Properties", "level": 1, "chunk_id": "12.0", "text": "# Changing Properties\naxis_properties[\"AxisBoxAttachement\"] = [\"microxas/motorisation/galilbox\"]\naxis_properties[\"AxisEncoderType\"] = [\"1\"]\naxis_properties[\"AxisNumber\"] = [\"6\"]\naxis1.put_property(axis_properties)\n```", "text_sha1": "856626cbe2b2506b434ac01d5a5d3f9986f587f3"}
{"doc_id": "9a595bdf5e7657a34f2ef33a1e6dd4d5e94d1ea2", "path": "pytango-docsv10.1.12/tutorial/green_modes.md", "section": "Green mode", "level": 1, "chunk_id": "0.0", "text": "# Green mode\n\n```{toctree}\n:maxdepth: 1\n:hidden: true\n\ngreen_modes/green_modes_client\ngreen_modes/green_modes_server\n```\n\nPyTango supports cooperative green Tango objects. Since version 8.1 two *green*\nmodes have been added: {obj}`~tango.GreenMode.Futures` and\n{obj}`~tango.GreenMode.Gevent`. In version 9.2.0 another one has been\nadded: {obj}`~tango.GreenMode.Asyncio`.\n\n:::{note}\nThe preferred mode to use for new projects is {obj}`~tango.GreenMode.Asyncio`.\nSupport for this mode will take priority over the others.\n:::\n\nThe {obj}`~tango.GreenMode.Futures` uses the standard python module\n{mod}`concurrent.futures`.\nThe {obj}`~tango.GreenMode.Gevent` mode uses the well known [gevent](https://www.gevent.org) library.\nThe newest, {obj}`~tango.GreenMode.Asyncio` mode, uses [asyncio](https://docs.python.org/3/library/asyncio.html) - a Python\nlibrary for asynchronous programming (it's featured as a part of a standard\nPython distribution since version 3.5 of Python; it's available on PyPI for\nolder ones).\n\nYou can set the PyTango green mode at a global level. Set the environment\nvariable {envvar}`PYTANGO_GREEN_MODE` to either *futures*, *gevent* or *asyncio*\n(case-insensitive). If this environment variable is not defined the PyTango\nglobal green mode defaults to *Synchronous*.", "text_sha1": "d48044157f1a7125a061da80e82a578272372b02"}
{"doc_id": "c85073b977e4550b3a1412932190bd1125563ad5", "path": "pytango-docsv10.1.12/tutorial/green_modes/green_modes_client.md", "section": "Client green modes", "level": 1, "chunk_id": "0.0", "text": "# Client green modes\n\nYou can also change the active global green mode at any time in your program:\n\n```\n>>> from tango import DeviceProxy, GreenMode\n>>> from tango import set_green_mode, get_green_mode\n\n>>> get_green_mode()\ntango.GreenMode.Synchronous\n\n>>> dev = DeviceProxy(\"sys/tg_test/1\")\n>>> dev.get_green_mode()\ntango.GreenMode.Synchronous\n\n>>> set_green_mode(GreenMode.Futures)\n>>> get_green_mode()\ntango.GreenMode.Futures\n\n>>> dev.get_green_mode()\ntango.GreenMode.Futures\n```\n\nAs you can see by the example, the global green mode will affect any previously\ncreated {class}`DeviceProxy` using the default *DeviceProxy* constructor\nparameters.\n\nYou can specificy green mode on a {class}`DeviceProxy` at creation time.\nYou can also change the green mode at any time:\n\n```\n>>> from tango.futures import DeviceProxy\n\n>>> dev = DeviceProxy(\"sys/tg_test/1\")\n>>> dev.get_green_mode()\ntango.GreenMode.Futures\n\n>>> dev.set_green_mode(GreenMode.Synchronous)\n>>> dev.get_green_mode()\ntango.GreenMode.Synchronous\n```", "text_sha1": "e2cf3324d6bedfb00bf8b4015974b4c923471e9d"}
{"doc_id": "c85073b977e4550b3a1412932190bd1125563ad5", "path": "pytango-docsv10.1.12/tutorial/green_modes/green_modes_client.md", "section": "futures mode", "level": 2, "chunk_id": "1.0", "text": "## futures mode\n\nUsing {mod}`concurrent.futures` cooperative mode in PyTango is relatively easy:\n\n```\n>>> from tango.futures import DeviceProxy\n\n>>> dev = DeviceProxy(\"sys/tg_test/1\")\n>>> dev.get_green_mode()\ntango.GreenMode.Futures\n\n>>> print(dev.state())\nRUNNING\n```\n\nThe {func}`tango.futures.DeviceProxy` API is exactly the same as the standard\n{class}`~tango.DeviceProxy`. The difference is in the semantics of the methods\nthat involve synchronous network calls (constructor included) which may block\nthe execution for a relatively big amount of time.\nThe list of methods that have been modified to accept *futures* semantics are,\non the {func}`tango.futures.DeviceProxy`:\n\n- Constructor\n- {meth}`~DeviceProxy.state`\n- {meth}`~DeviceProxy.status`\n- {meth}`~DeviceProxy.read_attribute`\n- {meth}`~DeviceProxy.write_attribute`\n- {meth}`~DeviceProxy.write_read_attribute`\n- {meth}`~DeviceProxy.read_attributes`\n- {meth}`~DeviceProxy.write_attributes`\n- {meth}`~DeviceProxy.ping`\n\nSo how does this work in fact? I see no difference from using the *standard*\n{class}`~tango.DeviceProxy`.\nWell, this is, in fact, one of the goals: be able to use a *futures* cooperation\nwithout changing the API. Behind the scenes the methods mentioned before have\nbeen modified to be able to work cooperatively.\n\nAll of the above methods have been boosted with two extra keyword arguments\n*wait* and *timeout* which allow to fine tune the behaviour.\nThe *wait* parameter is by default set to `True` meaning wait for the request\nto finish (the default semantics when not using green mode).\nIf *wait* is set to `True`, the timeout determines the maximum time to wait for\nthe method to execute. The default is `None` which means wait forever. If *wait*\nis set to `False`, the *timeout* is ignored.\n\nIf *wait* is set to `True`, the result is the same as executing the\n*standard* method on a {class}`~tango.DeviceProxy`.\nIf, *wait* is set to `False`, the result will be a\n{class}`concurrent.futures.Future`. In this case, to get the actual value\nyou will need to do something like:\n\n```\n>>> from tango.futures import DeviceProxy\n\n>>> dev = DeviceProxy(\"sys/tg_test/1\")\n>>> result = dev.state(wait=False)\n>>> result\n<Future at 0x16cb310 state=pending>\n\n>>> # this will be the blocking code\n>>> state = result.result()\n>>> print(state)\nRUNNING\n```\n\nHere is another example using {meth}`~DeviceProxy.read_attribute`:\n\n```\n>>> from tango.futures import DeviceProxy\n\n>>> dev = DeviceProxy(\"sys/tg_test/1\")\n>>> result = dev.read_attribute('wave', wait=False)\n>>> result\n<Future at 0x16cbe50 state=pending>\n\n>>> dev_attr = result.result()\n>>> print(dev_attr)\nDeviceAttribute[\ndata_format = tango.AttrDataFormat.SPECTRUM\n dim_x = 256\n dim_y = 0\n has_failed = False\n is_empty = False\n name = 'wave'\n nb_read = 256\n nb_written = 0\n quality = tango.AttrQuality.ATTR_VALID\nr_dimension = AttributeDimension(dim_x = 256, dim_y = 0)\n time = TimeVal(tv_nsec = 0, tv_sec = 1383923329, tv_usec = 451821)\n type = tango.CmdArgType.DevDouble\n value = array([ -9.61260664e-01, -9.65924853e-01, -9.70294813e-01,\n -9.74369212e-01, -9.78146810e-01, -9.81626455e-01,\n -9.84807087e-01, -9.87687739e-01, -9.90267531e-01,\n ...\n 5.15044507e-1])\n w_dim_x = 0\n w_dim_y = 0\nw_dimension = AttributeDimension(dim_x = 0, dim_y = 0)\n w_value = None]\n```", "text_sha1": "84aa228c30529f8a26cb704534263aabb3ea78c2"}
{"doc_id": "c85073b977e4550b3a1412932190bd1125563ad5", "path": "pytango-docsv10.1.12/tutorial/green_modes/green_modes_client.md", "section": "gevent mode", "level": 2, "chunk_id": "2.0", "text": "## gevent mode\n\n:::{warning}\nBefore using gevent mode please note that at the time of writing this\ndocumentation, *tango.gevent* requires the latest version 1.0 of\ngevent (which has been released the day before :-P).\n:::\n\nUsing [gevent](https://www.gevent.org) cooperative mode in PyTango is relatively easy:\n\n```\n>>> from tango.gevent import DeviceProxy\n\n>>> dev = DeviceProxy(\"sys/tg_test/1\")\n>>> dev.get_green_mode()\ntango.GreenMode.Gevent\n\n>>> print(dev.state())\nRUNNING\n```\n\nThe {func}`tango.gevent.DeviceProxy` API is exactly the same as the standard\n{class}`~tango.DeviceProxy`. The difference is in the semantics of the methods\nthat involve synchronous network calls (constructor included) which may block\nthe execution for a relatively big amount of time.\nThe list of methods that have been modified to accept *gevent* semantics are,\non the {func}`tango.gevent.DeviceProxy`:\n\n- Constructor\n- {meth}`~DeviceProxy.state`\n- {meth}`~DeviceProxy.status`\n- {meth}`~DeviceProxy.read_attribute`\n- {meth}`~DeviceProxy.write_attribute`\n- {meth}`~DeviceProxy.write_read_attribute`\n- {meth}`~DeviceProxy.read_attributes`\n- {meth}`~DeviceProxy.write_attributes`\n- {meth}`~DeviceProxy.ping`\n\nSo how does this work in fact? I see no difference from using the *standard*\n{class}`~tango.DeviceProxy`.\nWell, this is, in fact, one of the goals: be able to use a gevent cooperation\nwithout changing the API. Behind the scenes the methods mentioned before have\nbeen modified to be able to work cooperatively with other greenlets.\n\nAll of the above methods have been boosted with two extra keyword arguments\n*wait* and *timeout* which allow to fine tune the behaviour.\nThe *wait* parameter is by default set to `True` meaning wait for the request\nto finish (the default semantics when not using green mode).\nIf *wait* is set to `True`, the timeout determines the maximum time to wait for\nthe method to execute. The default timeout is `None` which means wait forever.\nIf *wait* is set to `False`, the *timeout* is ignored.\n\nIf *wait* is set to `True`, the result is the same as executing the\n*standard* method on a {class}`~tango.DeviceProxy`.\nIf, *wait* is set to `False`, the result will be a\n{class}`gevent.event.AsyncResult`. In this case, to get the actual value\nyou will need to do something like:\n\n```\n>>> from tango.gevent import DeviceProxy\n\n>>> dev = DeviceProxy(\"sys/tg_test/1\")\n>>> result = dev.state(wait=False)\n>>> result\n<gevent.event.AsyncResult at 0x1a74050>\n\n>>> # this will be the blocking code\n>>> state = result.get()\n>>> print(state)\nRUNNING\n```\n\nHere is another example using {meth}`~DeviceProxy.read_attribute`:\n\n```\n>>> from tango.gevent import DeviceProxy\n\n>>> dev = DeviceProxy(\"sys/tg_test/1\")\n>>> result = dev.read_attribute('wave', wait=False)\n>>> result\n<gevent.event.AsyncResult at 0x1aff54e>\n\n>>> dev_attr = result.get()\n>>> print(dev_attr)\nDeviceAttribute[\ndata_format = tango.AttrDataFormat.SPECTRUM\n dim_x = 256\n dim_y = 0\n has_failed = False\n is_empty = False\n name = 'wave'\n nb_read = 256\n nb_written = 0\n quality = tango.AttrQuality.ATTR_VALID\nr_dimension = AttributeDimension(dim_x = 256, dim_y = 0)\n time = TimeVal(tv_nsec = 0, tv_sec = 1383923292, tv_usec = 886720)\n type = tango.CmdArgType.DevDouble\n value = array([ -9.61260664e-01, -9.65924853e-01, -9.70294813e-01,\n -9.74369212e-01, -9.78146810e-01, -9.81626455e-01,\n -9.84807087e-01, -9.87687739e-01, -9.90267531e-01,\n ...\n 5.15044507e-1])\n w_dim_x = 0\n w_dim_y = 0\nw_dimension = AttributeDimension(dim_x = 0, dim_y =", "text_sha1": "cb467d15fcb4061323dcdbb182afaa6dbf164d69"}
{"doc_id": "c85073b977e4550b3a1412932190bd1125563ad5", "path": "pytango-docsv10.1.12/tutorial/green_modes/green_modes_client.md", "section": "gevent mode", "level": 2, "chunk_id": "2.1", "text": "0)\n w_value = None]\n```\n\n:::{note}\ndue to the internal workings of gevent, setting the *wait* flag to\n`True` (default) doesn't prevent other greenlets from running in *parallel*.\nThis is, in fact, one of the major bonus of working with {mod}`gevent` when\ncompared with {mod}`concurrent.futures`\n:::", "text_sha1": "82c8a5f5ba4681306401d64f54c6291e8dc21057"}
{"doc_id": "c85073b977e4550b3a1412932190bd1125563ad5", "path": "pytango-docsv10.1.12/tutorial/green_modes/green_modes_client.md", "section": "asyncio mode", "level": 2, "chunk_id": "3.0", "text": "## asyncio mode\n\n[Asyncio](https://docs.python.org/3/library/asyncio.html) mode is similar to gevent, but it uses explicit coroutines. You can compare gevent and asyncio examples.\n\n```{literalinclude} ../../../examples/asyncio_green_mode/asyncio_simple_example.py\n:linenos: true\n```\n\nBelow you can find a TCP server example, which runs in an asynchronous mode and waits for a device's attribute name from a TCP client, then asks the device for a value and replies to the TCP client.\n\n```{literalinclude} ../../../examples/asyncio_green_mode/tcp_server_example.py\n:linenos: true\n```", "text_sha1": "022fa34f236ee590e90491236528191cd6cce807"}
{"doc_id": "5a1f284fbee3f3437e2de747b4eb4ff44e8036ed", "path": "pytango-docsv10.1.12/tutorial/green_modes/green_modes_server.md", "section": "Server green modes", "level": 1, "chunk_id": "0.0", "text": "# Server green modes\n\nPyTango server API from version 9.2.0 supports two green modes:\n{obj}`~tango.GreenMode.Gevent` and {obj}`~tango.GreenMode.Asyncio`.\nBoth can be used in writing new device servers in an asynchronous way.\n\n:::{note}\nIf your device server has multiple devices they must all use\nthe same green mode.\n:::\n\n(green-modes-no-sync-warning)=\n\n:::{warning}\nThese green modes disable Tango's [device server serialisation](https://tango-controls.readthedocs.io/en/latest/Explanation/threading.html#serialization-model-within-a-device-server),\ni.e., {obj}`tango.SerialModel.NO_SYNC` is automatically passed to {func}`tango.Util.set_serial_model`,\nwhen the device server starts. From those docs: \"This is an exotic kind of serialization and\nshould be used with **extreme care** only with devices which are fully thread safe.\"\n:::", "text_sha1": "c666d55183d54c7c18a284de504651dc1ba3c4b9"}
{"doc_id": "5a1f284fbee3f3437e2de747b4eb4ff44e8036ed", "path": "pytango-docsv10.1.12/tutorial/green_modes/green_modes_server.md", "section": "gevent mode", "level": 2, "chunk_id": "1.0", "text": "## gevent mode\n\nThis mode lets you convert your existing devices to asynchronous devices\neasily. You just add `green_mode = tango.GreenMode.Gevent` line to your device\nclass. Consider this example:\n\n```\nclass GeventDevice(Device):\n green_mode = tango.GreenMode.Gevent\n```\n\nEvery method in your device class will be treated as a\ncoroutine implicitly. This can be beneficial, but also potentially dangerous\nas it is a lot harder to debug. You should use this green mode with care.\n{obj}`~tango.GreenMode.Gevent` green mode is useful when you don't want to\nchange too much in your existing code (or you don't feel comfortable with\nwriting syntax of asynchronous calls).\n\nAnother thing to keep in mind is that when using {obj}`~tango.GreenMode.Gevent`\ngreen mode is that the Tango monitor lock is disabled, so the client requests can\nbe processed concurrently.\n\nGreenlets can also be used to spawn tasks in the background.\n\n(server-green-mode-asyncio)=", "text_sha1": "dce38b325e841dcfcf4f7d9ce44cff774059665b"}
{"doc_id": "5a1f284fbee3f3437e2de747b4eb4ff44e8036ed", "path": "pytango-docsv10.1.12/tutorial/green_modes/green_modes_server.md", "section": "asyncio mode", "level": 2, "chunk_id": "2.0", "text": "## asyncio mode\n\nThe way asyncio green mode on the server side works is it redirects all user\ncode to an event loop. This means that all user methods become coroutines, so\nin Python > 3.5 you should define them with `async` keyword.\nThis also means that in order to convert existing code of your devices\nto {obj}`~tango.GreenMode.Asyncio` green mode you will have to introduce\nat least those changes. But, of course, to truly benefit from this green mode\n(and asynchronous approach in general), you should introduce more far-fetched changes!\n\nThe main benefit of asynchronous programing approach is that it lets you\ncontrol precisely when code is run sequentially without interruptions and\nwhen control can be given back to the event loop. It's especially useful\nif you want to perform some long operations and don't want to prevent clients\nfrom accessing other parts of your device (attributes, in particular). This\nmeans that in {obj}`~tango.GreenMode.Asyncio` green mode there is no monitor\nlock!\n\nThe example below shows how asyncio can be used to write an asynchronous\nTango device:\n\n```{literalinclude} ../../../examples/asyncio_green_mode/asyncio_device_example.py\n:linenos: true\n```", "text_sha1": "9381c8b145b2c5baa5c890b73150a564ea289f4a"}
{"doc_id": "5808778021bc52804c13acf30bbca0b4c32bd073", "path": "pytango-docsv10.1.12/tutorial/itango.md", "section": "ITango", "level": 1, "chunk_id": "0.0", "text": "# ITango\n\nITango is a PyTango CLI based on [IPython](https://ipython.org). It is designed to be used as an\nIPython profile.\n\n> ```{image} ../_static/itango00.png\n> ```\n\nITango is available since PyTango 7.1.2 and has been moved to a separate\nproject since PyTango 9.2.0:\n\n- [package and instructions on PyPI](http://pypi.python.org/pypi/itango)\n- [sources on GitLab](https://gitlab.com/tango-controls/itango)\n- [documentation on pythonhosted](http://pythonhosted.org/itango)", "text_sha1": "d23520982441d8bdc27dfed4bd804092dd942cee"}
{"doc_id": "c809a8d3c4dac98f3c9e1d809c8ebe797cd8b592", "path": "pytango-docsv10.1.12/tutorial/logging.md", "section": "Server logging in Python", "level": 1, "chunk_id": "0.0", "text": "# Server logging in Python\n\nThis chapter instructs you on how to use the tango logging API (log4tango) to\ncreate tango log messages on your device server.\n\nThe logging system explained here is the Tango Logging Service (TLS). For\ndetailed information on how this logging system works please check:\n\n> - [Usage](https://tango-controls.readthedocs.io/en/latest/Explanation/device-server-model.html#the-tango-logging-service)\n> - [Property reference](https://tango-controls.readthedocs.io/en/latest/Reference/reference.html#the-device-logging)\n\nThe easiest way to start seeing log messages on your device server console is\nby starting it with the verbose option. Example:\n\n```\npython PyDsExp.py PyDs1 -v4\n```\n\nThis activates the console tango logging target and filters messages with\nimportance level DEBUG or more.\nThe links above provided detailed information on how to configure log levels\nand log targets. In this document we will focus on how to write log messages on\nyour device server.", "text_sha1": "4f436fc5a9dd019f0c8bf1d6406f88d1571e296c"}
{"doc_id": "c809a8d3c4dac98f3c9e1d809c8ebe797cd8b592", "path": "pytango-docsv10.1.12/tutorial/logging.md", "section": "Basic logging", "level": 2, "chunk_id": "1.0", "text": "## Basic logging\n\nThe most basic way to write a log message on your device is to use the\n{class}`~tango.server.Device` logging related methods:\n\n> - {meth}`~tango.server.Device.debug_stream`\n> - {meth}`~tango.server.Device.info_stream`\n> - {meth}`~tango.server.Device.warn_stream`\n> - {meth}`~tango.server.Device.error_stream`\n> - {meth}`~tango.server.Device.fatal_stream`\n\nExample:\n\n```\ndef read_voltage(self):\n self.info_stream(\"read voltage attribute\")\n # ...\n return voltage_value\n```\n\nThis will print a message like:\n\n```\n1282206864 [-1215867200] INFO test/power_supply/1 read voltage attribute\n```\n\nevery time a client asks to read the *voltage* attribute value.\n\nThe logging methods support argument list feature (since PyTango 8.1). Example:\n\n```\ndef read_voltage(self):\n self.info_stream(\"read_voltage(%s, %d)\", self.host, self.port)\n # ...\n return voltage_value\n```", "text_sha1": "51ddb6d4d7a0e4e272fc114d405b9ad6e9dea371"}
{"doc_id": "c809a8d3c4dac98f3c9e1d809c8ebe797cd8b592", "path": "pytango-docsv10.1.12/tutorial/logging.md", "section": "Logging with print statement", "level": 2, "chunk_id": "2.0", "text": "## Logging with print statement\n\n*This feature is only possible since PyTango 7.1.3*\n\nIt is possible to use the print statement to log messages into the tango logging\nsystem. This is achieved by using the python's print extend form sometimes\nrefered to as *print chevron*.\n\nSame example as above, but now using *print chevron*:\n\n```\ndef read_voltage(self, the_att):\n print >>self.log_info, \"read voltage attribute\"\n # ...\n return voltage_value\n```\n\nOr plain print:\n\n```\ndef read_Long_attr(self, the_att):\n print(\"read voltage attribute\", file=self.log_info)\n # ...\n return voltage_value\n```", "text_sha1": "b667b5f40a8b0c541d5f8fd24bd66cdfddaa3273"}
{"doc_id": "c809a8d3c4dac98f3c9e1d809c8ebe797cd8b592", "path": "pytango-docsv10.1.12/tutorial/logging.md", "section": "Logging with decorators", "level": 2, "chunk_id": "3.0", "text": "## Logging with decorators\n\n*This feature is only possible since PyTango 7.1.3*\n\nPyTango provides a set of decorators that place automatic log messages when\nyou enter and when you leave a python method. For example:\n\n```\n@tango.DebugIt()\ndef read_Long_attr(self, the_att):\n the_att.set_value(self.attr_long)\n```\n\nwill generate a pair of log messages each time a client asks for the 'Long_attr'\nvalue. Your output would look something like:\n\n```\n1282208997 [-1215965504] DEBUG test/pydsexp/1 -> read_Long_attr()\n1282208997 [-1215965504] DEBUG test/pydsexp/1 <- read_Long_attr()\n```\n\nDecorators exist for all tango log levels:\n: - {class}`tango.DebugIt`\n - {class}`tango.InfoIt`\n - {class}`tango.WarnIt`\n - {class}`tango.ErrorIt`\n - {class}`tango.FatalIt`\n\nThe decorators receive three optional arguments:\n: - show_args - shows method arguments in log message (defaults to False)\n - show_kwargs shows keyword method arguments in log message (defaults to False)\n - show_ret - shows return value in log message (defaults to False)\n\nExample:\n\n```\n@tango.DebugIt(show_args=True, show_ret=True)\ndef IOLong(self, in_data):\n return in_data * 2\n```\n\nwill output something like:\n\n```\n1282221947 [-1261438096] DEBUG test/pydsexp/1 -> IOLong(23)\n1282221947 [-1261438096] DEBUG test/pydsexp/1 46 <- IOLong()\n```", "text_sha1": "695ef1e39ed255a6bffeb87118f8dda93ffeb022"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Quick start", "level": 2, "chunk_id": "1.0", "text": "## Quick start\n\nSince PyTango 8.1 it has become much easier to program a Tango device server.\nPyTango provides some helpers that allow developers to simplify the programming\nof a Tango device server.\n\nBefore reading this chapter you should be aware of the TANGO basic concepts.\nThis chapter does not explain what a Tango device or a device server is.\nThis is explained in detail in the\n[Tango control system manual](http://www.tango-controls.org/documentation/kernel/)\n\nYou may also read the [high level server API](#pytango-hlapi) for the complete reference API.\n\nBefore creating a server you need to decide:\n\n1. The Tango Class name of your device (example: `Clock`). In our\n example we will use the same name as the python class name.\n2. The list of attributes of the device, their data type, access (read-only vs\n read-write), data_format (scalar, 1D, 2D)\n3. The list of commands, their parameters and their result\n\nHere is a simple example on how to write a *Clock* device server using the\nhigh level API\n\n```{code-block} python\n:linenos: true\n\n import time\n from tango.server import Device, device_property, attribute, command\n\n class Clock(Device):\n\n model = device_property(dtype=str)\n\n @attribute\n def time(self):\n return time.time()\n\n @command(dtype_in=str, dtype_out=str)\n def strftime(self, format):\n return time.strftime(format)\n\n if __name__ == \"__main__\":\n Clock.run_server()\n```\n\n**line 2**\n\n: import the necessary symbols\n\n**line 5**\n\n: tango device class definition. A Tango device must inherit from\n {class}`tango.server.Device`\n\n**line 7**\n\n: definition of the *model* property. Check the\n {class}`~tango.server.device_property` for the complete list of options\n\n**line 9-11**\n\n: definition of the *time* attribute. By default, attributes are double, scalar,\n read-only. Check the {class}`~tango.server.attribute` for the complete\n list of attribute options.\n\n**line 13-15**\n\n: the method *strftime* is exported as a Tango command. In receives a string\n as argument and it returns a string. If a method is to be exported as a\n Tango command, it must be decorated as such with the\n {func}`~tango.server.command` decorator\n\n**line 18**\n\n: start the Tango run loop. This method automatically determines the Python\n class name and exports it as a Tango class. For more complicated cases,\n check {func}`~tango.server.run` for the complete list of options\n\nBefore running this brand new server we need to register it in the Tango system.\nYou can do it with Jive (`Jive->Edit->Create server`):\n\n```{image} ../_static/jive_clock.png\n```\n\n... or in a python script:\n\n```\nimport tango\n\ndev_info = tango.DbDevInfo()\ndev_info.server = \"Clock/test\"\ndev_info._class = \"Clock\"\ndev_info.name = \"test/Clock/1\"\n\ndb = tango.Database()\ndb.add_device(dev_info)\n```", "text_sha1": "cd0ff1bd0c63fc5131e1ff85246642f2e0d528e1"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Start server from command line", "level": 2, "chunk_id": "2.0", "text": "## Start server from command line\n\nTo start server from the command line execute the following command:\n\n```console\n$ python Clock.py test\nReady to accept request\n```\n\n:::{note}\nIn this example, the name of the server and the name of the tango\nclass are the same: `Clock`. This pattern is enforced by the\n{meth}`~tango.server.Device.run_server` method. However, it is possible\nto run several tango classes in the same server. In this case, the server\nname would typically be the name of server file. See the\n{func}`~tango.server.run` function for further information.\n:::\n\nTo run server without database use option `-nodb`.\n\n```console\n$ python <server_file>.py <instance_name> -nodb -port 10000\nReady to accept request\n```\n\nNote, that to start server in this mode you should provide a port with either `--port`, or `--ORBendPoint` option\n\nAdditionally, you can use the following options:\n\n:::{note}\nall long-options can be provided in non-POSIX format: `-port` or `--port`, etc...\n:::\n\n```console\n-h, -?, --help : show usage help\n\n-v, --verbose: set the trace level. Can be user in count way: -vvvv set level to 4 or --verbose --verbose set to 2\n\n-vN: directly set the trace level to N, e.g., -v3 - set level to 3\n\n--file <file_name>: start a device server using an ASCII file instead of the Tango database\n\n--host <host_name>: force the host from which server accept requests\n\n--port <port>: force the port on which the device server listens\n\n--nodb: run server without DB\n\n--dlist <dev1,dev2,etc>: the device name list. This option is supported only with the -nodb option\n\n--ORBendPoint giop:tcp:<host>:<port>: Specifying the host from which server accept requests and port on which the device server listens.\n```\n\n:::{note}\nany ORB option can be provided if it starts with --ORB\\<option>\n:::\n\nAdditionally, in Windows the following option can be used:\n\n```console\n-i: install the service\n\n-s: install the service and choose the automatic startup mode\n\n-u: uninstall the service\n\n--dbg: run in console mode to debug service. The service must have been installed prior to use it.\n```", "text_sha1": "f9d76390bd78111ad8796d2d6900a9ffa9b0f0b4"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Advanced attributes configuration", "level": 2, "chunk_id": "3.0", "text": "## Advanced attributes configuration\n\nThere is a more detailed clock device server in the examples/Clock folder.\n\nHere is a more complete example on how to write a *PowerSupply* device server\nusing the high level API. The example contains:\n\n1. a *host* device property\n2. a *port* class property\n3. the standard initialisation method called *init_device*\n4. a read/write double scalar expert attribute *current*\n5. a read-only double scalar attribute called *voltage*\n6. a read-only double image attribute called *noise*\n7. a read/write float scalar attribute *range*, defined with pythonic-style decorators, which can be always read, but conditionally written\n8. a read/write float scalar attribute *compliance*, defined with alternative decorators\n9. an *output_on_off* command\n\n```{code-block} python\n:linenos: true\n\nfrom time import time\nfrom numpy.random import random_sample\n\nfrom tango import AttrQuality, AttrWriteType, DevState, DispLevel, AttReqType\nfrom tango.server import Device, attribute, command\nfrom tango.server import class_property, device_property\n\nclass PowerSupply(Device):\n _my_current = 2.3456\n _my_range = 0.0\n _my_compliance = 0.0\n _output_on = False\n\n host = device_property(dtype=str)\n port = class_property(dtype=int, default_value=9788)\n\n def init_device(self):\n super().init_device()\n self.info_stream(f\"Power supply connection details: {self.host}:{self.port}\")\n self.set_state(DevState.ON)\n self.set_status(\"Power supply is ON\")\n\n current = attribute(\n label=\"Current\",\n dtype=float,\n display_level=DispLevel.EXPERT,\n access=AttrWriteType.READ_WRITE,\n unit=\"A\",\n format=\"8.4f\",\n min_value=0.0,\n max_value=8.5,\n min_alarm=0.1,\n max_alarm=8.4,\n min_warning=0.5,\n max_warning=8.0,\n fget=\"get_current\",\n fset=\"set_current\",\n doc=\"the power supply current\",\n )\n\n noise = attribute(\n label=\"Noise\",\n dtype=((float,),),\n max_dim_x=1024,\n max_dim_y=1024,\n fget=\"get_noise\",\n )\n\n @attribute\n def voltage(self):\n return 10.0\n\n def get_current(self):\n return self._my_current\n\n def set_current(self, current):\n print(\"Current set to %f\" % current)\n self._my_current = current\n\n def get_noise(self):\n return random_sample((1024, 1024))\n\n range = attribute(label=\"Range\", dtype=float)\n\n @range.setter\n def range(self, new_range):\n self._my_range = new_range\n\n @range.getter\n def current_range(self):\n return self._my_range, time(), AttrQuality.ATTR_WARNING\n\n @range.is_allowed\n def can_range_be_changed(self, req_type):\n if req_type == AttReqType.WRITE_REQ:\n return not self._output_on\n return True\n\n compliance = attribute(label=\"Compliance\", dtype=float)\n\n @compliance.read\n def compliance(self):\n return self._my_compliance\n\n @compliance.write\n def new_compliance(self, new_compliance):\n self._my_compliance = new_compliance\n\n @command(dtype_in=bool, dtype_out=bool)\n def output_on_off(self, on_off):\n self._output_on = on_off\n return self._output_on\n\nif __name__ == \"__main__\":\n PowerSupply.run_server()\n```\n\n(dynamic-attributes-howto)=", "text_sha1": "d5cf568494578da6253b104d9fd6d6f6485095de"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Create attributes dynamically", "level": 2, "chunk_id": "4.0", "text": "## Create attributes dynamically\n\nIt is also possible to create dynamic attributes within a Python device server.\nThere are several ways to create dynamic attributes. One of the ways, is to\ncreate all the devices within a loop, then to create the dynamic attributes and\nfinally to make all the devices available for the external world. In a C++ device\nserver, this is typically done within the \\<Device>Class::device_factory() method.\nIn Python device server, this method is generic and the user does not have one.\nNevertheless, this generic device_factory provides the user with a way to create\ndynamic attributes.\n\nUsing the high-level API, you can re-define a method called\n{meth}`~tango.server.Device.initialize_dynamic_attributes`\non each \\<Device>. This method will be called automatically by the device_factory for\neach device. Within this method you create all the dynamic attributes.\n\nIf you are still using the low-level API with a \\<Device>Class instead of just a \\<Device>,\nthen you can use the generic device_factory's call to the\n{meth}`~tango.DeviceClass.dyn_attr` method.\nIt is simply necessary to re-define this method within your \\<Device>Class and to create\nthe dynamic attributes within this method.\n\nInternally, the high-level API re-defines {meth}`~tango.DeviceClass.dyn_attr` to call\n{meth}`~tango.server.Device.initialize_dynamic_attributes` for each device.\n\n:::{note}\nThe `dyn_attr()` (and `initialize_dynamic_attributes()` for high-level API) methods\nare only called **once** when the device server starts, since the Python device_factory\nmethod is only called once. Within the device_factory method, `init_device()` is\ncalled for all devices and only after that is `dyn_attr()` called for all devices.\nIf the `Init` command is executed on a device it will not call the `dyn_attr()` method\nagain (and will not call `initialize_dynamic_attributes()` either).\n:::\n\nThere is another point to be noted regarding dynamic attributes within a Python\ndevice server. The Tango Python device server core checks that for each\nstatic attribute there exists methods named \\<attribute_name>\\_read and/or\n\\<attribute_name>\\_write and/or is\\_\\<attribute_name>\\_allowed. Using dynamic\nattributes, it is not possible to define these methods because attribute names\nand number are known only at run-time.\nTo address this issue, you need to provide references to these methods when\ncalling {meth}`~tango.server.Device.add_attribute`.\n\nThe recommended approach with the high-level API is to reference these methods when\ninstantiating a {class}`tango.server.attribute` object using the fget, fset and/or\nfisallowed kwargs (see example below). Where fget is the method which has to be\nexecuted when the attribute is read, fset is the method to be executed\nwhen the attribute is written and fisallowed is the method to be executed\nto implement the attribute state machine. This {class}`tango.server.attribute` object\nis then passed to the {meth}`~tango.server.Device.add_attribute` method.\n\n:::{note}\nIf the fget (fread), fset (fwrite) and fisallowed are given as str(name) they must be methods\nthat exist on your Device class. If you want to use plain functions, or functions belonging to a\ndifferent class, you should pass a callable.\n:::\n\nWhich arguments you have to provide depends on the type of the attribute. For example,\na WRITE attribute does not need a read method.\n\n:::{note}\nStarting from PyTango 9.4.0 the read methods for dynamic attributes\ncan also be implemented with the high-leve", "text_sha1": "68052d84c3be6f9c4c899b33ebc52d812400a444"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Create attributes dynamically", "level": 2, "chunk_id": "4.1", "text": "l API. Prior to that, only the low-level\nAPI was available.\n:::\n\nFor the read function it is possible to use one of the following signatures:\n\n```\ndef low_level_read(self, attr):\n attr.set_value(self.attr_value)\n\ndef high_level_read(self, attr):\n return self.attr_value\n```\n\nFor the write function there is only one signature:\n\n```\ndef low_level_write(self, attr):\n self.attr_value = attr.get_write_value()\n```\n\nHere is an example of a device which creates a dynamic attribute on startup:\n\n```\nfrom tango import AttrWriteType\nfrom tango.server import Device, attribute\n\nclass MyDevice(Device):\n\n def initialize_dynamic_attributes(self):\n self._values = {\"dyn_attr\": 0}\n attr = attribute(\n name=\"dyn_attr\",\n dtype=int,\n access=AttrWriteType.READ_WRITE,\n fget=self.generic_read,\n fset=self.generic_write,\n fisallowed=self.generic_is_allowed,\n )\n self.add_attribute(attr)\n\n def generic_read(self, attr):\n attr_name = attr.get_name()\n value = self._values[attr_name]\n return value\n\n def generic_write(self, attr):\n attr_name = attr.get_name()\n value = attr.get_write_value()\n self._values[attr_name] = value\n\n def generic_is_allowed(self, request_type):\n # note: we don't know which attribute is being read!\n # request_type will be either AttReqType.READ_REQ or AttReqType.WRITE_REQ\n return True\n```\n\nAnother way to create dynamic attributes is to do it some time after the device has\nstarted. For example, using a command. In this case, we just call the\n{meth}`~tango.server.Device.add_attribute` method when necessary.\n\nHere is an example of a device which has a TANGO command called\n*CreateFloatAttribute*. When called, this command creates a new scalar floating\npoint attribute with the specified name:\n\n```\nfrom tango import AttrWriteType\nfrom tango.server import Device, attribute, command\n\nclass MyDevice(Device):\n\n def init_device(self):\n super(MyDevice, self).init_device()\n self._values = {}\n\n @command(dtype_in=str)\n def CreateFloatAttribute(self, attr_name):\n if attr_name not in self._values:\n self._values[attr_name] = 0.0\n attr = attribute(\n name=attr_name,\n dtype=float,\n access=AttrWriteType.READ_WRITE,\n fget=self.generic_read,\n fset=self.generic_write,\n )\n self.add_attribute(attr)\n self.info_stream(\"Added dynamic attribute %r\", attr_name)\n else:\n raise ValueError(f\"Already have an attribute called {repr(attr_name)}\")\n\n def generic_read(self, attr):\n attr_name = attr.get_name()\n self.info_stream(\"Reading attribute %s\", attr_name)\n value = self._values[attr.get_name()]\n attr.set_value(value)\n\n def generic_write(self, attr):\n attr_name = attr.get_name()\n value = attr.get_write_value()\n self.info_stream(\"Writing attribute %s - value %s\", attr_name, value)\n self._values[attr.get_name()] = value\n```\n\nAn approach more in line with the low-level API is also possible, but not recommended for\nnew devices. The Device_3Impl::add_attribute() method has the following\nsignature:\n\n> `add_attribute(self, attr, r_meth=None, w_meth=None, is_allo_meth=None)`\n\nattr is an instance of the {class}`tango.Attr` class, r_meth is the method which has to be\nexecuted when the attribute is read, w_meth is the method to be executed\nwhen the attribute is written and is_allo_meth is the method to be executed\nto implement the attribute state machine.\n\nOld example:\n\n```\nfrom tango import Attr, AttrWriteType\nfrom tango.server import Device, command\n\nclass MyOldDevice(Device):\n\n @command(dtype_in=str)\n def CreateFloatAttribute(self, attr_name):\n attr = Attr(attr_name, tango.DevDouble, AttrWriteTy", "text_sha1": "3e89f5bcd5de84c8ed1396abbbbe5598cb150f94"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Create attributes dynamically", "level": 2, "chunk_id": "4.2", "text": "pe.READ_WRITE)\n self.add_attribute(attr, self.read_General, self.write_General)\n\n def read_General(self, attr):\n self.info_stream(\"Reading attribute %s\", attr.get_name())\n attr.set_value(99.99)\n\n def write_General(self, attr):\n self.info_stream(\"Writing attribute %s - value %s\", attr.get_name(), attr.get_write_value())\n```\n\n(decorators)=", "text_sha1": "e372afd9c2683a28981904917bc20748f63199f7"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Attributes and commands with decorated functions", "level": 2, "chunk_id": "5.0", "text": "## Attributes and commands with decorated functions\n\nPyTango offers support of decorated methods for attributes methods (read, write and is_allowed) as well as for commands (command and is_allowed method)\nNevertheless, there are a few peculiarities:\n\n1. for **attributes**, all additional decorators must be applied below the `@attribute` decorator:\n\n```python", "text_sha1": "119e2762a3e3da1bf3249eedcba5cdd8195c3ec2"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "invalid attribute declaration!!!", "level": 1, "chunk_id": "7.0", "text": "# invalid attribute declaration!!!\n@my_perfect_decorator\n@attribute\ndef bad_attribute(self) -> str:\n return \"But this does not\"\n```\n\n2. for sync, futures and gevent green mode **commands**, the sequence of decorators is not as strict:\n\n```python", "text_sha1": "13aabcb6b1ae80a8bf231ec4367325541d102930"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "also valid command declaration", "level": 1, "chunk_id": "9.0", "text": "# also valid command declaration\n@my_perfect_decorator\n@command\ndef alternative_command(self) -> str:\n return \"This works, but has some limitations\"\n```\n\n:::{note}\nThere is a small difference: for all decorators applied *below* `@command` (as shown in first example above)\nit will be possible to put breakpoints in their code, and they will be included in\n[test coverage](#test-coverage) reports.\nThis is not the case for any decorators applied *above* `@command` (thus the limitations for\nthe second example above).\n:::\n\n3. for asyncio green mode **commands**, the sequence of decorators is similar to other green modes, but all\n decorators applied *below* `@command` must be async while all decorators applied *above* `@command` must\n be sync:\n\n```python", "text_sha1": "d36601e34e9699a2ca377ca52ab997b0d86a1b3f"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "valid async command declaration", "level": 1, "chunk_id": "10.0", "text": "# valid async command declaration\n@my_perfect_sync_decorator\n@command\n@my_perfect_async_decorator\nasync def good_command(self) -> str:\n return \"This works\"", "text_sha1": "2c2e6d282eea351c293b48bc1555b237c6cec29e"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "this won't work either", "level": 1, "chunk_id": "12.0", "text": "# this won't work either\n@my_perfect_async_decorator\n@command\n@my_perfect_async_decorator\nasync def another_bad_command(self) -> str:\n return \"This does not either\"", "text_sha1": "90c78649118bd52b80e74598acbdcb092b67fa6b"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "and this won't work", "level": 1, "chunk_id": "13.0", "text": "# and this won't work\n@my_perfect_async_decorator\n@command\n@my_perfect_sync_decorator\nasync def also_a_bad_command(self) -> str:\n return \"Nor does this work\"\n```\n\n(type-hint)=", "text_sha1": "53a3e9c63a56c946bfd662df79c6acd1962c0ddb"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Use Python type hints when declaring a device", "level": 2, "chunk_id": "14.0", "text": "## Use Python type hints when declaring a device\n\nStarting from PyTango 9.5.0 the data type of properties, attributes and commands\nin high-level API device servers can be declared using Python type hints.\n\nThis is the same simple *PowerSupply* device server, but using type hints in various ways:\n\n```{code-block} python\n:linenos: true\n\n from time import time\n from numpy.random import random_sample\n\n from tango import AttrQuality, AttrWriteType, DevState, DispLevel, AttReqType\n from tango.server import Device, attribute, command\n from tango.server import class_property, device_property\n\n class PowerSupply(Device):\n _my_current = 2.3456\n _my_range = 0\n _my_compliance = 0.0\n _output_on = False\n\n host: str = device_property()\n port: int = class_property(default_value=9788)\n\n def init_device(self):\n super().init_device()\n self.info_stream(f\"Power supply connection details: {self.host}:{self.port}\")\n self.set_state(DevState.ON)\n self.set_status(\"Power supply is ON\")\n\n current: float = attribute(\n label=\"Current\",\n display_level=DispLevel.EXPERT,\n access=AttrWriteType.READ_WRITE,\n unit=\"A\",\n format=\"8.4f\",\n min_value=0.0,\n max_value=8.5,\n min_alarm=0.1,\n max_alarm=8.4,\n min_warning=0.5,\n max_warning=8.0,\n fget=\"get_current\",\n fset=\"set_current\",\n doc=\"the power supply current\",\n )\n\n noise: list[list[float]] = attribute(\n label=\"Noise\", max_dim_x=1024, max_dim_y=1024, fget=\"get_noise\"\n )\n\n @attribute\n def voltage(self) -> float:\n return 10.0\n\n def get_current(self):\n return self._my_current\n\n def set_current(self, current):\n print(\"Current set to %f\" % current)\n self._my_current = current\n\n def get_noise(self):\n return random_sample((1024, 1024))\n\n range = attribute(label=\"Range\")\n\n @range.getter\n def current_range(self) -> tuple[float, float, AttrQuality]:\n return self._my_range, time(), AttrQuality.ATTR_WARNING\n\n @range.setter\n def range(self, new_range: float):\n self._my_range = new_range\n\n @range.is_allowed\n def can_range_be_changed(self, req_type):\n if req_type == AttReqType.WRITE_REQ:\n return not self._output_on\n return True\n\n compliance = attribute(label=\"Compliance\")\n\n @compliance.read\n def compliance(self) -> float:\n return self._my_compliance\n\n @compliance.write\n def new_compliance(self, new_compliance: float):\n self._my_compliance = new_compliance\n\n @command\n def output_on_off(self, on_off: bool) -> bool:\n self._output_on = on_off\n return self._output_on\n\n if __name__ == \"__main__\":\n PowerSupply.run_server()\n```\n\n:::{note}\nTo defining DevEncoded attribute you can use type hints *tuple\\[str, bytes\\]* and *tuple\\[str, bytearray\\]*\n(or *tuple\\[str, bytes, float, AttrQuality\\]* and *tuple\\[str, bytearray, float, AttrQuality\\]*).\n\nType hints *tuple\\[str, str\\]* (or *tuple\\[str, str, float, AttrQuality\\]*) will be recognized as SPECTRUM DevString attribute with max_dim_x=2\n\nIf you want to create DevEncoded attribute with *(str, str)* return you have to use dtype kwarg\n:::\n\n:::{note}\nTo defining DevVarLongStringArray and DevVarDoubleStringArray commands you can use type hints *tuple\\[tuple\\[int\\], tuple\\[str\\]\\]* and *tuple\\[tuple\\[float\\], tuple\\[str\\]\\]*\n(or *tuple\\[tuple\\[int\\], tuple\\[str\\], float, AttrQuality\\]* and *tuple\\[tuple\\[float\\], tuple\\[str\\], float, AttrQuality\\]*), respectively. You can use also list\\[\\] declarations in all combinations.\nSince commands does not have dimension parameter, length of the tuple\\[\\] is ignored (see description of commands below)\n:::\n\n:::{note}\nThere are some peculiarities with type hints if you ar", "text_sha1": "1bf5699dd3eb09d0b3a1215a50f17349a7de1b3d"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Use Python type hints when declaring a device", "level": 2, "chunk_id": "14.1", "text": "e using \"from \\_\\_future\\_\\_ import annotations\":\nIn that case, Python doesn't try to resolve the names of the types inside the type hints.\nInstead, it stores them as strings. PyTango will try to resolve it later; however, this functionality is not guaranteed.\n:::\n\n**Properties**\n\nTo define device property you can use:\n\n```python\nhost: str = device_property()\n```\n\nIf you want to create list property you can use *tuple\\[\\]*, *list\\[\\]* or *numpy.typing.NDArray\\[\\]* annotation:\n\n```python\nchannels: tuple[int] = device_property()\n```\n\nor\n\n```python\nchannels: list[int] = device_property()\n```\n\nor\n\n```python\nchannels: numpy.typing.NDArray[np.int_] = device_property()\n```\n\n**Attributes**\nFor the attributes you can use one of the following patterns:\n\n```python\nvoltage: float = attribute()\n```\n\nor\n\n```python\nvoltage = attribute()\n\ndef read_voltage(self) -> float:\n return 10.0\n```\n\nor\n\n```python\nvoltage = attribute(fget=\"query_voltage\")\n\ndef query_voltage(self) -> float:\n return 10.0\n```\n\nor\n\n```python\n@attribute\ndef voltage(self) -> float:\n return 10.0\n```\n\nFor writable (AttrWriteType.READ_WRITE and AttrWriteType.WRITE) attributes you can also define the type in write functions.\n\n:::{note}\nDefining the type hint of a READ_WRITE attribute *only* in the write function is not recommended as it can lead to inconsistent code.\n:::\n\n```python\ndata_to_save = attribute(access=AttrWriteType.WRITE)", "text_sha1": "7d3a8c3b92aec604ee8bb3670ec2ac9f7870a106"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "its type can be defined here", "level": 1, "chunk_id": "16.0", "text": "# its type can be defined here\ndef write_data_to_save(self, data: float)\n self._hardware.save(value)\n```\n\n:::{note}\nIf you provide a type hint in several places (e.g., dtype kwarg and read function): there is no check, that types are the same and attribute type will be taken according to the following priority:\n\n1. dtype kwarg\n2. attribute assignment\n3. read function\n4. write function\n:::\n\nE.g., if you create the following attribute:\n\n```python\nvoltage: int = attribute(dtype=float)\n\ndef read_voltage(self) -> str:\n return 10\n```\n\nthe attribute type will be float\n\n**SPECTRUM and IMAGE attributes**\n\nAs for the case of properties, the SPECTRUM and IMAGE attributes can be defined by *tuple\\[\\]*, *list\\[\\]* or *numpy.typing.NDArray\\[\\]* annotation.\n\n:::{note}\nSince there isn't yet official support for *numpy.typing.NDArray\\[\\]* shape definitions (as at 12 October 2023: <https://github.com/numpy/numpy/issues/16544>) you **must** provide a *dformat* kwarg as well as *max_dim_x* (and, if necessary, *max_dim_y*):\n:::\n\n```python\n@attribute(dformat=AttrDataFormat.SPECTRUM, max_dim_x=3)\ndef get_time(self) -> numpy.typing.NDArray[np.int_]:\n return hours, minutes, seconds\n```\n\nIn case of *tuple\\[\\]*, *list\\[\\]* you can automatically specify attribute dimension:\n\n```python\n@attribute\ndef get_time(self) -> tuple[int, int, int]:\n return hours, minutes, seconds\n```\n\nor you can use max_dim_x(max_dim_y) kwarg with just one element in tuple/list:\n\n```python\n@attribute(max_dim_x=3)\ndef get_time(self) -> list[int]: # can be also tuple[int]\n return hours, minutes, seconds\n```\n\n:::{note}\nIf you provide both max_dim_x(max_dim_y) kwarg and use *tuple\\[\\]* annotation, kwarg will have priority\n:::\n\n:::{note}\nMixing element types within a spectrum(image) attribute definition is not supported by Tango and will raise a RuntimeError.\n:::\n\ne.g., attribute\n\n```python\n@attribute(max_dim_x=3)\ndef get_time(self) -> tuple[float, str]:\n return hours, minutes, seconds\n```\n\nwill result in RuntimeError\n\nDimension of SPECTRUM attributes can be also taken from annotation:\n\n```python\n@attribute()\ndef not_matrix(self) -> tuple[tuple[bool, bool], tuple[bool, bool]]:\n return [[False, True],[True, False]]\n```\n\n:::{note}\nmax_y will be len of outer tuple (or list), max_x - len of the inner. Note, that all inner tuples(lists) must be the same length\n:::\n\ne.g.,\n\n```python\ntuple[tuple[bool, bool], tuple[bool, bool], tuple[bool, bool]]\n```\n\nwill result in max_y=3, max_x=2\n\nwhile\n\n```python\ntuple[tuple[bool, bool], tuple[bool], tuple[bool]]\n```\n\nwill result in RuntimeError\n\n**Commands**\n\nDeclaration of commands is the same as declaration of attributes with decorators:\n\n```python\n@command\ndef set_and_check_voltage(self, voltage_to_set: float) -> float:\n device.set_voltage(voltage_to_set)\n return device.get_voltage()\n```\n\n:::{note}\nIf you provide both type hints and dtype kwargs, the kwargs take priority:\n:::\n\ne.g.,\n\n```python\n@command(dtype_in=float, dtype_out=float)\ndef set_and_check_voltage(self, voltage_to_set: str) -> str:\n device.set_voltage(voltage_to_set)\n return device.get_voltage()\n```\n\nwill be a command that accepts float and returns float.\n\nAs in case of attributes, the SPECTRUM commands can be declared with *tuple\\[\\]* or *list\\[\\]* annotation:\n\n```python\n@command\ndef set_and_check_voltages(self, voltages_set: tuple[float, float]) -> tuple[float, float]:\n device.set_voltage(channel1, voltages_set[0])\n device.set_voltage(channel2, voltages_set[1])\n return device.get_voltage(channel=1", "text_sha1": "dc4d9e2493c9c61c37ce84f1e01c66493b6af363"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "its type can be defined here", "level": 1, "chunk_id": "16.1", "text": "), device.get_voltage(channel=2)\n```\n\n:::{note}\nSince commands do not have dimension parameters, length of tuple/list does not matter. If the type hints indicates 2 floats in the input, PyTango does not check that the input for each call received arrived with length 2.\n:::\n\n**Dynamic attributes with type hint**\n\n:::{note}\nStarting from PyTango 9.5.0 dynamic attribute type can be defined by type hints in the read/write methods.\n:::\n\nUsage of type hints is described in {ref}`type-hint` .\nThe only difference in case of dynamic attributes is, that there is no option to use type hint in attribute at assignment\n\ne.g., the following code won't work:\n\n```python\ndef initialize_dynamic_attributes(self):\n voltage: float = attribute() # CANNOT BE AN OPTION FOR DYNAMIC ATTRIBUTES!!!!!!!!\n self.add_attribute(attr)\n```\n\n(version-info)=", "text_sha1": "389d1fef912ae3df73cce639843a46e426a1c0e3"}
{"doc_id": "1dca9ed5a3b4d51ee9a05a9003dfab6985ebc7ca", "path": "pytango-docsv10.1.12/tutorial/servers.md", "section": "Add detailed version information to a device", "level": 2, "chunk_id": "17.0", "text": "## Add detailed version information to a device\n\nSince PyTango v10.0.0, devices can add custom version information, using\nthe {meth}`~tango.server.Device.add_version_info` method. A copy of the version information\ndict can be read within the device using the {meth}`~tango.server.Device.get_version_info` method.\nClients can get the information using the standard {meth}`~tango.DeviceProxy.info` method.\n\n```python\nfrom tango.server import Device\n\n__version__ = \"1.0.0\"\n\nclass Demo(Device):\n\n def init_device(self):\n super().init_device()\n self.add_version_info(\"MyDemo.Name\", \"Demo version info\")\n self.add_version_info(\"MyDemo.Source\", __file__)\n self.add_version_info(\"MyDemo.Version\", __version__)\n\nif __name__ == \"__main__\":\n Demo.run_server()\n```\n\nPut the above code in a file called `ver_info_demo.py`. Then run it locally without a Tango database\nin your PyTango environment using the {mod}`tango.test_context` module\n(which uses {class}`~tango.test_context.DeviceTestContext`):\n\n```console\n$ python -m tango.test_context ver_info_demo.Demo --host 127.0.0.1\nCan't create notifd event supplier. Notifd event not available\nReady to accept request\nDemo started on port 8888 with properties {}\nDevice access: tango://127.0.0.1:8888/test/nodb/demo#dbase=no\nServer access: tango://127.0.0.1:8888/dserver/Demo/demo#dbase=no\n```\n\nThen you can access the information as a client. Note the {meth}`~tango.DeviceProxy.info` method\nreturns a {class}`~tango.DeviceInfo` object with some additional information:\n\n```\n>>> from tango import DeviceProxy\n\n>>> dp = DeviceProxy(\"tango://127.0.0.1:8888/test/nodb/demo#dbase=no\")\n>>> info = dp.info()\n>>> print(info)\nDeviceInfo[\n dev_class = \"Demo\"\n dev_type = \"Demo\"\n doc_url = \"Doc URL = http://www.tango-controls.org\"\n server_host = \"myhost.domain\"\n server_id = \"Demo/Demo\"\n server_version = 6\n version_info = {\n \"Build.PyTango.NumPy\": \"2.2.3\",\n \"Build.PyTango.Pybind11\": \"3.0.1\",\n \"Build.PyTango.Python\": \"3.13.2\",\n \"Build.PyTango.cppTango\": \"10.0.2\",\n \"MyDemo.Name\": \"Demo version info\",\n \"MyDemo.Source\": \"/path/to/ver_info_demo.py\",\n \"MyDemo.Version\": \"1.0.0\",\n \"NumPy\": \"2.2.3\",\n \"PyTango\": \"10.1.0.dev1\",\n \"Python\": \"3.13.2\",\n \"cppTango\": \"10.0.2\",\n \"cppTango.git_revision\": \"unknown\",\n \"cppzmq\": \"41000\",\n \"idl\": \"6.0.2\",\n \"omniORB\": \"4.3.2\",\n \"opentelemetry-cpp\": \"1.18.0\",\n \"zmq\": \"40305\"\n }\n]\n>>> print(info.version_info[\"MyDemo.Version\"])\n1.0.0\n```", "text_sha1": "43adde33920607015f37257169c6657504bd4e74"}
